<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>vizia-book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">vizia-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vizia/vizia-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>Welcome to the Vizia book!</p>
<p>Vizia is a crate for building desktop GUI applications. It presently supports Windows, Linux, and MacOS desktop targets.</p>
<p>The Vizia project's home is <a href="https://github.com/vizia">https://github.com/vizia</a> and the main Vizia repository is <a href="https://github.com/vizia/vizia">https://github.com/vizia/vizia</a>.</p>
<p>This book aims to act as a guide and reference for Vizia, and hopes to teach you how to use Vizia, whether you've done any GUI programming in the past or not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>The Vizia framework is built using the Rust programming language. Currently, to use Vizia, you will need to install the Rust compiler by following the instructions over at <a href="https://www.rust-lang.org/learn/get-started">https://www.rust-lang.org/learn/get-started</a>.</p>
<h2 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h2>
<p>The <a href="https://github.com/vizia/vizia">Vizia repository</a> on github contains a number of example applications. To run these examples, first clone the repository to a local directory, then with your terminal of choice, navigate to this directory and run the following command:</p>
<pre><code>cargo run --example name_of_example
</code></pre>
<p>Where <code>name_of_example</code> should be replaced with the example name.</p>
<h2 id="join-the-community"><a class="header" href="#join-the-community">Join the Community</a></h2>
<p>For help with vizia, or to get involved with contributing to the project, come join us on our <a href="https://discord.gg/aNkTPsRm2w">Discord server</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>In this quick start guide we'll build a very simple counter application consisting of two buttons, one for incrementing the counter and one for decrementing, and a label showing the counter value.</p>
<p>This guide will introduce the reader to the basics of vizia, including setting up an application, composing and modifying views, layout, styling, reactivity, localization and accessibility. The final application will look like the following:</p>
<img src="quickstart/img/styling.png" alt="Image showing a finished counter vizia application."/>
<h2 id="reactive-ui"><a class="header" href="#reactive-ui">Reactive UI</a></h2>
<p>Vizia is a reactive UI framework. This means that visual elements which represent some state of the application will update when this state changes. Interacting with these visual elements causes the application state to change.</p>
<p>A reactive UI then is a feedback loop of application state change and visual element updates.</p>
<p>In Vizia, this pattern can be broken down into four concepts:</p>
<ol>
<li><strong>Models</strong> - Data representing the state of an application.</li>
<li><strong>Views</strong> - The visual elements which present the application state as a graphical user interface.</li>
<li><strong>Binding</strong> - The link between model data and views which causes them to update when the data changes.</li>
<li><strong>Events</strong> - Messages which views send to models to trigger changes to the data.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up"><a class="header" href="#setting-up">Setting Up</a></h1>
<h2 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a new project</a></h2>
<p>First, let's create a new Rust project using the following command:</p>
<pre><code class="language-bash">cargo new --bin hello_vizia
</code></pre>
<p>This will generate a <code>hello_vizia</code> directory with the following contents:</p>
<pre><code class="language-bash">.
├── Cargo.toml
├── .git
├── .gitignore
└── src
    └── main.rs
</code></pre>
<h2 id="adding-vizia-as-a-dependency"><a class="header" href="#adding-vizia-as-a-dependency">Adding Vizia as a dependency</a></h2>
<p>Open the <code>Cargo.toml</code> file and add the following to the dependencies:</p>
<pre><code class="language-toml">[package]
name = "hello_vizia"
version = "0.1.0"
edition = "2021"

[dependencies]
vizia = {git = "https://github.com/vizia/vizia"}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-an-application"><a class="header" href="#creating-an-application">Creating an Application</a></h1>
<p>The first step to building a GUI with vizia is to create an application. Creating a new application creates a root window and a <a href="https://docs.vizia.dev/vizia/context/struct.Context.html"><code>context</code></a>. Views declared within the closure passed to <code>Application::new()</code> are added to the context and rendered into the root window.</p>
<p>Add the following code to the <code>main.rs</code> file, replacing the hello world code that was generated for us:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        // Content goes here
    })
    .run()    
}</code></pre>
<p>The <code>run()</code> method on the <code>Application</code> causes the program to enter the event loop and for the main window to display.</p>
<p>We can run our application with <code>cargo run</code> in the terminal, which should result in the following:</p>
<p align="center">
<img src="quickstart/img/application.png" alt="An empty vizia application window"/>
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-the-window"><a class="header" href="#modifying-the-window">Modifying the Window</a></h1>
<p>When creating an <code>Application</code> the properties of the window can be changed using <a href="https://docs.vizia.dev/vizia/window/trait.WindowModifiers.html">window modifiers</a>. These modifiers are methods called on the application prior to calling <code>run()</code>.</p>
<p>For example, the <code>title()</code> and <code>inner_size()</code> window modifiers can be used to set the title and size of the window respectively.</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

    })
    .title("Counter")
    .inner_size((400, 150))
    .run()
}</code></pre>
<p align="center">
<img src="quickstart/img/window_modifiers.png" alt="An empty vizia application window with a custom title and inner size"/>
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="adding-views"><a class="header" href="#adding-views">Adding Views</a></h1>
<p>Views are the building bocks of a vizia GUI and are used to visually present <a href="quickstart/./model_data.html">model data</a> and to act as controls which, when interacted with, send events to mutate model data.</p>
<p>We'll learn more about models and events in the following sections.</p>
<h2 id="adding-a-label"><a class="header" href="#adding-a-label">Adding a label</a></h2>
<p>We can declare a <code>Label</code> view with the following code:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        Label::new(cx, "Hello Vizia");
    })
    .title("Counter")
    .inner_size((400, 150))
    .run()
}</code></pre>
<p>The first argument to the <code>new()</code> method of the label is a mutable reference to <code>Context</code>, shortened to <code>cx</code>. This allows the view to build itself into the application. For the second argument we pass it a string to display.</p>
<p align="center">
<img src="quickstart/img/basic_view.png" alt="A vizia application window with a label view reading 'Hello Vizia'"/>
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-views"><a class="header" href="#modifying-views">Modifying Views</a></h1>
<p>Modifiers are used to customize the appearance and behavior of views in a declarative way. Many of the built-in modifiers in Vizia can be applied to any View, which includes built-in views as well as user-defined views.</p>
<h2 id="customizing-the-label-with-a-modifier"><a class="header" href="#customizing-the-label-with-a-modifier">Customizing the label with a modifier</a></h2>
<p>Applying modifiers to a view changes the properties of a view without rebuilding it. For example, we can use the <code>background_color()</code> modifier to set the background color of the label view:</p>
<pre><code class="language-rust">Label::new(cx, "Hello Vizia")
    .background_color(Color::rgb(200, 200, 200));</code></pre>
<img src="quickstart/img/view_modifier.png" alt=""/>
<p>Note how this overrides the default background color of the label, which is provided by a CSS stylesheet.</p>
<p>Multiple modifiers can be chained together to achieve more complex view configuration.</p>
<pre><code class="language-rust">Label::new(cx, "Hello Vizia")
    .width(Pixels(200.0))
    .border_width(Pixels(1.0))
    .border_color(Color::black())
    .background_color(Color::rgb(200, 200, 200));</code></pre>
<img src="quickstart/img/view_modifiers.png" alt=""/>
<h2 id="view-specific-modifiers"><a class="header" href="#view-specific-modifiers">View specific modifiers</a></h2>
<p>Some views have modifiers which are specific to that view type. For example, the <code>Slider</code> view has a modifier for setting the slider <code>range</code>:</p>
<pre><code class="language-rust">Slider::new(cx, AppData::value)
    .range(0.0..100.0);</code></pre>
<p>View specific modifiers can still be combined with regular modifiers, and the order doesn't matter. Both of these produce the same result:</p>
<pre><code class="language-rust">Slider::new(cx, AppData::value)
    .range(0.0..100.0)
    .width(Pixels(200.0));</code></pre>
<pre><code class="language-rust">Slider::new(cx, AppData::value)
    .width(Pixels(200.0))
    .range(0.0..100.0);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composing-views"><a class="header" href="#composing-views">Composing Views</a></h1>
<p>Composition of views is achieved through container views. These views take a closure which allows us to build child views within them. Some container views may also arrange their content in a particular way.</p>
<p>For example, the <code>HStack</code> container view will arrange its contents into a horizontal row. Let's use this to declare the rest of the views for our counter application:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        HStack::new(cx, |cx|{
            Button::new(cx, |cx| Label::new(cx, "Decrement"));
            Button::new(cx, |cx| Label::new(cx, "Increment"));
            Label::new(cx, "0");
        });
    })
    .title("Counter")
    .inner_size((400, 150))
    .run()
}</code></pre>
<p>For now we have hard-coded the label to display the number 0, but later we will hook this up to some model data so that it updates when the data changes. We've also removed the modifiers from the label, as we'll be replacing these with CSS styling later on.</p>
<p>Note that the <code>Button</code> view is also a container, and is designed to allow things like a button with both text and a leading or trailing icon.</p>
<p align="center">
<img src="quickstart/img/composing_views.png" alt="A vizia app showing two buttons and a label"/>
</p>
<p>Composing views together forms a tree, where each view has a single parent and zero or more children. For example, for the code above the view tree can be depicted with the following diagram:</p>
<p align="center">
<img src="quickstart/img/view_tree.svg" alt="Diagram of the vizia application view tree"/>
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="customizing-the-layout"><a class="header" href="#customizing-the-layout">Customizing the Layout</a></h1>
<p>So far we have a horizontal row of buttons and a label, but they're positioned in the top left corner. Let's use layout modifiers to position the views in the center of the window with some space between them.</p>
<h2 id="centering-the-views"><a class="header" href="#centering-the-views">Centering the views</a></h2>
<p>By default the <code>HStack</code> view will stretch to fill its parent, in this case the window. We can center the contents of the <code>HStack</code> using the <code>alignment()</code> modifier and setting it to <code>Alignment::Center</code>. Then we can add horizontal space between the children using the <code>gap()</code> modifier:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        HStack::new(cx, |cx|{
            Button::new(cx, |cx| Label::new(cx, "Decrement"));
            Button::new(cx, |cx| Label::new(cx, "Increment"));
            Label::new(cx, "0");
        })
        .alignment(Alignment::Center)
        .gap(Pixels(20.0));
    })
    .inner_size((400, 100))
    .run()
}</code></pre>
<img src="quickstart/img/layout.png" alt="A vizia app showing two buttons and a label"/>
<h2 id="understanding-the-layout-system"><a class="header" href="#understanding-the-layout-system">Understanding the layout system</a></h2>
<p>The layout system used by vizia is called <a href="https://github.com/vizia/morphorm">morphorm</a> and can achieve results similar to flexbox on the web but with fewer concepts to learn. Vizia determines the position and size of views based on a number of layout properties which can be configured. A detailed guide of the layout system can be found <a href="quickstart/../layout/layout.html">here</a>.</p>
<!-- ### Layout Type
The children of a view will be arranged into a stack. The `layout-type` property determines how children of a view will be arranged. There are two variants:
- `Row` - The view will arrange its children into a horizontal row.
- `Column` - The view will arrange its children into a vertical column.

### Position Type
The `position-type` property determines whether a view should be positioned in-line with its siblings in a stack, or out-of-line and independently of its siblings. There are two variants:
- `ParentDirected` - The view will be positioned relative to its in-line position with its siblings.
- `SelfDirected` - The view will be positioned out-of-line and relative to the top-left corner of its parent.

### Space
The position of an individual view within a stack can be adjusted by the spacing applied to each of its four sides:
- `left` - The space that should be applied to the left side of the view. This takes precedent over `right` spacing.
- `right` - The space that should be applied to the right side of the view.
- `top` - The space that should be applied to the top side of (above) the view. This takes precedent over `bottom` space.
- `bottom` - The space that should be applied to the bottom side of (below) the view.

The `space` property can be used to set the spacing on all four sides of a view simultaneously.

Spacing is specified with `Units`, which has four variants:
- `Pixels(val)` - Sets the spacing to a fixed number of pixels.
- `Percentage(val)` - Sets the spacing to a percentage of the view's parent size.
- `Stretch(factor)` - Sets the spacing to a proportion of the free space of the parent within the same axis.
- `Auto` - Sets the spacing to inherit the child spacing of the parent.

### Child Space
The `child space` property of a view can be used to apply space around its children by overriding the individual `Auto` spacing of the children and is also specified with `Units`. Child space can also be applied to individual sides of a view:
- `child_left` - The space that should be applied between the left side of the view and its children with individual `Auto` `left` spacing. Applies to all children in a vertical stack and to the first child in a horizontal stack.
- `child_right` - The space that should be applied between the right side of the view and its children with individual `Auto` `right` spacing. Applies to all children in a vertical stack and to the first child in a horizontal stack.
- `child_top` - The space that should be applied between the top side of the view and its children with individual `Auto` `top` spacing. Applies to all children in a horizontal stack and to the first child in a vertical stack.
- `child_bottom` - The space that should be applied between the bottom side of the view and its children with individual `Auto` `bottom` spacing. Applies to all children in a horizontal stack and to the first child in a vertical stack.

### Size
The size of a view is determined by its `width` and `height` properties, which are also specified with `Units`:
- `Pixels(val)` - Sets the size to a fixed number of pixels.
- `Percentage(val)` - Sets the size to a percentage of the view's parent size.
- `Stretch(factor)` - Sets the size to a proportion of the free space of the parent within the same axis.
- `Auto` - Sets the size to either hug the view's children, or to inherit the content size of the view, for example the size of any text within the view. Self-directed children do not contribute to the size of the view when the view size is set to auto.

The `width` and `height` can also be set simultaneously with the `size` property.

### Constraints
All spacing and size properties can be constrained with corresponding minimum and maximum properties, which are also specified using `Units`. For example, the `width` of a view can be constrained with the `min_width` and `max_width` properties.
 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling-the-application"><a class="header" href="#styling-the-application">Styling the Application</a></h1>
<p>Previously we saw how modifiers can be used to style views inline. However, vizia also allows views to be styled with Cascading Style Sheets (CSS) so that style rules can be shared by multiple views. Additionally, stylesheets can be reloaded at runtime by pressing the F5 key.</p>
<h2 id="adding-class-names-to-the-views"><a class="header" href="#adding-class-names-to-the-views">Adding class names to the views</a></h2>
<p>First we'll add some class names to our views, using the <code>class</code> style modifier, so we can target them with a CSS stylesheet:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        HStack::new(cx, |cx|{
            Button::new(cx, |cx| Label::new(cx, "Decrement"))
                .class("dec");
            Button::new(cx, |cx| Label::new(cx, "Increment"))
                .class("inc");
            Label::new(cx, "0")
                .class("count");
        })
        .class("row");
    })
    .title("Counter")
    .inner_size((400, 150))
    .run()
}</code></pre>
<h2 id="creating-a-stylesheet"><a class="header" href="#creating-a-stylesheet">Creating a stylesheet</a></h2>
<p>Next, we'll create a <code>style.css</code> file in the <code>src</code> directory with the following CSS code:</p>
<pre><code class="language-css">.row {
    alignment: center;
    gap: 20px;
}

button {
    border-width: 0px;
}

button.dec {
    background-color: rgb(170, 50, 50);
}

button.inc {
    background-color: rgb(50, 170, 50);
}

label.count {
    alignment: center;
    border-width: 1px;
    border-color: #808080;
    border-radius: 4px;
    width: 50px;
    height: 32px;
}
</code></pre>
<h2 id="adding-the-stylesheet-to-the-app"><a class="header" href="#adding-the-stylesheet-to-the-app">Adding the stylesheet to the app</a></h2>
<p>Finally, we'll add the CSS file to the vizia application using the <code>.add_stylesheet()</code> function on the context. Here we're using the <code>include_style!()</code> macro, which will dynamically load the stylesheet at runtime in debug mode, but include the stylesheet into the binary in release mode. This should be done just after creating the application:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        // Add the stylesheet to the app
        cx.add_stylesheet(include_style!("src/style.css"))
            .expect("Failed to load stylesheet");

        HStack::new(cx, |cx|{
            Button::new(cx, |cx| Label::new(cx, "Decrement"))
                .class("dec");
            Button::new(cx, |cx| Label::new(cx, "Increment"))
                .class("inc");
            Label::new(cx, "0")
                .class("count");
        })
        .class("row");
    })
    .title("Counter")
    .inner_size((400, 150))
    .run()
}</code></pre>
<p>If we run the app now with <code>cargo run</code> we get the following:</p>
<p align="center">
<img src="quickstart/img/styling.png" alt="A vizia app showing two buttons and a label"/>
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="animating-styles-with-transitions"><a class="header" href="#animating-styles-with-transitions">Animating Styles with Transitions</a></h1>
<p>Many of the style and layout properties in vizia can be animated. The simplest way to animate style properties is through CSS transitions.</p>
<p>Transitions are animations for style rule properties which apply when a view matches that rule. Transitions are specified with the <code>transition</code> CSS property, and you must specify the property to animate and the duration of the animation. Optionally you can also specify any delay on the animation, as well as the timing function used.</p>
<p>The default styling for some of the built-in views already has some of these transition. For example, if you hover a button you'll see its background color animate to a slightly lighter color.</p>
<h2 id="declaring-a-transition"><a class="header" href="#declaring-a-transition">Declaring a transition</a></h2>
<p>For example, we can create a transition for the background color of a view when hovered:</p>
<pre><code class="language-rust">use vizia::prelude::*;

const STYLE: &amp;str = r#"
    .my_view {
        background-color: red;
    }

    .my_view:hover {
        background-color: blue;
        transition: background-color 100ms;
    }
"#;

fn main () -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        cx.add_stylesheet(STYLE);

        Element::new(cx)
            .class("my_view")
            .size(Pixels(200.0));
    })
    .run()
}
</code></pre>
<p>Note here that we have not used the <code>include_style!()</code> macro within the call to <code>cx.add_stylesheet</code> as the stylesheet is defined as a constant within the Rust code.</p>
<p>// GIF here</p>
<p>Note that the transition only occurs when the cursor hovers the element and not when the cursor leaves the element (unless the transition did not complete when the cursor left). This is because the transition has been specified on the <code>:hover</code> state of the element, and so the background color will transition when going <em>to</em> this state.</p>
<p>To transition back again, we need to specify a transition on the non-hover state as well:</p>
<pre><code class="language-css">.my_view {
    background-color: red;
    transition: background-color 100ms;
}

.my_view:hover {
    background-color: blue;
    transition: background-color 100ms;
}
</code></pre>
<p>// GIF here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-data"><a class="header" href="#model-data">Model Data</a></h1>
<p>So far we've created the views for our counter application but we haven't declared the application data with the count value we want to display and modify.</p>
<p>Application data in Vizia is stored in models. Views can then bind to the data in these models in order to react to changes in the data.</p>
<h2 id="declaring-a-model"><a class="header" href="#declaring-a-model">Declaring a model</a></h2>
<p>A model definition can be any type, typically a struct, which implements the <code>Model</code> trait:</p>
<pre><code class="language-rust">pub struct AppData {
    pub count: i32,
}

impl Model for AppData {}</code></pre>
<h2 id="building-the-model-into-the-tree"><a class="header" href="#building-the-model-into-the-tree">Building the model into the tree</a></h2>
<p>To use a model, an instance of the data must be built into the application with the <code>build()</code> method:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        AppData { count: 0 }.build(cx); // Build the data into the app

        HStack::new(cx, |cx|{
            Button::new(cx, |cx| Label::new(cx, "Decrement"))
                .class("dec");
            Button::new(cx, |cx| Label::new(cx, "Increment"))
                .class("inc");
            Label::new(cx, "0")
                .class("count");
        })
        .class("row");

    })
    .title("Counter")
    .inner_size((400, 200))
    .run()
}
</code></pre>
<p>This builds the model data into the tree, in this case at the root <code>Window</code>. Internally, models and views are stored separately, however, for processes like event propagation, models can be thought of as existing within the tree, with an associated view.</p>
<p>Therefore, the model-view tree for the above code can be depicted with the following diagram:</p>
<p align="center">
<img src="quickstart/img/model_view_tree.svg" alt="Diagram of a basic model-view tree depicting a Window view, with an associated AppData model, as well as a child HStack view with two child Button views and a Label view">
</p>
<p>If the <code>AppData</code> had been built within the contents of the <code>HStack</code>, then the model would be associated with the <code>HStack</code> rather than the <code>Window</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lenses-and-data-binding"><a class="header" href="#lenses-and-data-binding">Lenses and Data Binding</a></h1>
<p>Now that we have some model data we can <em>bind</em> the <code>count</code> to the <code>Label</code> view.</p>
<p>Data binding is the concept of linking model data to views, so that when the model data is changed, the views observing this data update in response.</p>
<p>In Vizia, data binding is achieved through the use of lenses. A lens is an object which allows you to <em>select</em> some part of a model and inspect its value. These lens objects are then used to form a binding between views and these parts of the model, updating when only these specific parts have changed.</p>
<h2 id="generating-lenses"><a class="header" href="#generating-lenses">Generating lenses</a></h2>
<p>The <code>Lens</code> derive macro can be used to generate a lens for each field of a struct. These lenses can then be used to transform a reference to the struct into a reference to each of its fields. The generated lenses are given the same name as the field and placed in a module with the same name as the struct. For example, deriving <code>Lens</code> on the model we defined before:</p>
<pre><code class="language-rust">#[derive(Lens)]
pub struct AppData {
    count: i32,
}

impl Model for AppData {}</code></pre>
<p>A lens to the <code>count</code> field of the <code>AppData</code> struct is generated as <code>AppData::count</code>.</p>
<h2 id="binding-the-label"><a class="header" href="#binding-the-label">Binding the label</a></h2>
<p>With the generated <code>AppData::count</code> lens, we can bind the <code>count</code> data to the <code>Label</code> by passing the lens in place of the string:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        AppData { count: 0 }.build(cx);

        HStack::new(cx, |cx|{
            Button::new(cx, |cx| Label::new(cx, "Decrement"))
                .class("dec");
            Button::new(cx, |cx| Label::new(cx, "Increment"))
                .class("inc");
            Label::new(cx, AppData::count) // Bind the label to the count data
                .class("count");
        })
        .class("row");
    })
    .title("Counter")
    .inner_size((400, 100))
    .run()
}</code></pre>
<p>This sets up a binding which updates the value of the label whenever the <code>count</code> changes. We can depict this with the following diagram, where the green arrow shows the direct link between the data and the label:</p>
<p align="center">
<img src="quickstart/img/binding.svg" alt="Diagram of model-view-tree with an arrow from 'AppData' to 'Label' representing data binding"/>
</p>
<h2 id="modifier-bindings"><a class="header" href="#modifier-bindings">Modifier bindings</a></h2>
<p>Many modifiers also accept a lens as well as a value. When a lens is supplied to a modifier, a binding is set up which will update the modified property when the bound to model data changes. For example:</p>
<pre><code class="language-rust">
#[derive(Lens)]
pub struct AppData {
    color: Color,
}

...

Label::new(cx, "Hello World")
    .background_color(AppData::color);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutating-state-with-events"><a class="header" href="#mutating-state-with-events">Mutating State with Events</a></h1>
<p>The label is now bound to the data so that it updates when the count changes, so now we need to hook up the buttons to change the count.</p>
<p>Vizia uses events to communicate actions to update model or view data. These events propagate through the tree, typically from the view which emits the event, up through the ancestors of the view, to the main window and through any models on the way.</p>
<h2 id="declaring-events"><a class="header" href="#declaring-events">Declaring events</a></h2>
<p>An event contains a message which can be any type, but is typically an enum. We'll declare an event enum with two variants, one for incrementing the count and one for decrementing:</p>
<pre><code class="language-rust">pub enum AppEvent {
    Increment,
    Decrement,
}</code></pre>
<h2 id="emitting-events"><a class="header" href="#emitting-events">Emitting events</a></h2>
<p>Events are usually emitted in response to some action on a view. For this we can the <code>on_press</code> callback provided by the <code>Button</code>. When the button is pressed this callback is called. We can use the provided <code>EventContext</code> to emit our events up the tree:</p>
<pre><code class="language-rust">Button::new(cx, |cx| Label::new(cx, "Decrement"))
    .on_press(|ex| ex.emit(AppEvent::Decrement))
    .class("dec");
Button::new(cx, |cx| Label::new(cx, "Increment"))
    .on_press(|ex| ex.emit(AppEvent::Increment))
    .class("inc");</code></pre>
<p>The flow of events from the buttons, up through the visual tree, to <code>AppData</code> model can be described with the following diagram, where the red arrows indicate the direction of event propagation:</p>
<p align="center">
<img src="quickstart/img/event_propagation.svg" alt="Diagram of event propagation"/>
</p>
<h2 id="handling-events"><a class="header" href="#handling-events">Handling events</a></h2>
<p>Events are handled by views and models with the <code>event()</code> method of the <code>View</code> or <code>Model</code> traits. Let's fill in the <code>Model</code> implementation by implementing the <code>event</code> method:</p>
<pre><code class="language-rust">impl Model for AppData {
      fn event(&amp;mut self, cx: &amp;mut EventContext, event: &amp;mut Event) {
        event.map(|app_event, meta| match app_event {
            AppEvent::Decrement =&gt; self.count -= 1,
            AppEvent::Increment =&gt; self.count += 1,
        });
    }
}</code></pre>
<p>Calling <code>map()</code> on an event attempts to cast the event message to the specified type and calls the provided closure if it succeeds.</p>
<p>The closure provides the message type and an <code>EventMeta</code>, which can be used to query the origin and target views of the event, or to consume the event to prevent it propagating further.</p>
<p>If we run the application now we can see that the buttons cause the state to mutate, which then causes the label to update.</p>
<p align="center">
<img src="quickstart/img/events.gif" alt=""/>
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-the-counter-reusable"><a class="header" href="#making-the-counter-reusable">Making the Counter Reusable</a></h1>
<p>In this section we're going to turn our counter into a component by declaring a custom view. This will make our counter reusable so we can easily create multiple instances or export the counter as a component in a library.</p>
<h2 id="step-1-creating-a-custom-view-struct"><a class="header" href="#step-1-creating-a-custom-view-struct">Step 1: Creating a custom view struct</a></h2>
<p>First we declare a struct which will contain any view-specific state:</p>
<pre><code class="language-rust">pub struct Counter {}</code></pre>
<p>Although we could store the <code>count</code> value within the view, we've chosen instead to make this view 'stateless', and instead we'll provide it with a lens to bind to some external state (typically from a model), and some callbacks for emitting events when the buttons are pressed.</p>
<h2 id="step-2-implementing-the-view-trait"><a class="header" href="#step-2-implementing-the-view-trait">Step 2: Implementing the view trait</a></h2>
<p>Next, we'll implement the <code>View</code> trait for the custom counter view:</p>
<pre><code class="language-rust">impl View for Counter {}</code></pre>
<p>The <code>View</code> trait has methods for responding to events and for custom drawing, but for now we'll leave this implementation empty.</p>
<h2 id="step-3-building-the-sub-components-of-the-view"><a class="header" href="#step-3-building-the-sub-components-of-the-view">Step 3: Building the sub-components of the view</a></h2>
<p>Next we'll implement a constructor for the counter view. To use our view in a vizia application, the constructor must build the view into the context, which returns a <code>Handle</code> we can use to apply modifiers on our view.</p>
<pre><code class="language-rust">impl Counter {
    pub fn new(cx: &amp;mut Context) -&gt; Handle&lt;Self&gt; {
        Self {

        }.build(cx, |cx|{

        })
    }
}</code></pre>
<p>The <code>build()</code> function, provided by the <code>View</code> trait, takes a closure which we can use to construct the content of the custom view. Here we move the code which makes up the counter:</p>
<pre><code class="language-rust">impl Counter {
    pub fn new(cx: &amp;mut Context) -&gt; Handle&lt;Self&gt; {
        Self {

        }.build(cx, |cx|{
            HStack::new(cx, |cx|{
                Button::new(cx, |cx| Label::new(cx, "Decrement"))
                    .on_press(|ex| ex.emit(AppEvent::Decrement))
                    .class("dec");

                Button::new(cx, |cx| Label::new(cx, "Increment"))
                    .on_press(|ex| ex.emit(AppEvent::Increment))
                    .class("inc");
                
                Label::new(cx, AppData::count)
                    .class("count");
            })
            .class("row");
        })
    }
}</code></pre>
<h2 id="step-4-user-configurable-binding"><a class="header" href="#step-4-user-configurable-binding">Step 4: User-configurable binding</a></h2>
<p>The label within the counter is currently using the <code>AppData::count</code> lens, however, this will only work if that specific lens is in scope. To make this component truly reusable we need to pass a lens in via the constructor. To do this we use a generic and constrain the type to implement the <code>Lens</code> trait. This trait has a <code>Target</code> associated type which we can use to specify that the binding is for an <code>i32</code> value. Then we simply pass the lens directly to the constructor of the label:</p>
<pre><code class="language-rust">impl Counter {
    pub fn new&lt;L&gt;(cx: &amp;mut Context, lens: L) -&gt; Handle&lt;Self&gt; 
    where
        L: Lens&lt;Target = i32&gt;,
    {
        Self {

        }.build(cx, |cx|{
            HStack::new(cx, |cx|{
                Button::new(cx, |cx| Label::new(cx, "Decrement"))
                    .on_press(|ex| ex.emit(AppEvent::Decrement))
                    .class("dec");

                Button::new(cx, |cx| Label::new(cx, "Increment"))
                    .on_press(|ex| ex.emit(AppEvent::Increment))
                    .class("inc");
                
                Label::new(cx, lens)
                    .class("count");
            })
            .class("row");
        })
    }
}</code></pre>
<h2 id="step-5---user-configurable-events"><a class="header" href="#step-5---user-configurable-events">Step 5 - User-configurable events</a></h2>
<p>The last part required to make the counter truly reusable is to remove the dependency on <code>AppEvent</code>. To do this we'll add a couple of callbacks to the counter to allow the user to emit their own events when the buttons are presses.</p>
<h3 id="adding-callbacks-to-the-view"><a class="header" href="#adding-callbacks-to-the-view">Adding callbacks to the view</a></h3>
<p>First, change the <code>Counter</code> struct to look like this:</p>
<pre><code class="language-rust">pub struct Counter {
    on_increment: Option&lt;Box&lt;dyn Fn(&amp;mut EventContext)&gt;&gt;,
    on_decrement: Option&lt;Box&lt;dyn Fn(&amp;mut EventContext)&gt;&gt;,
}</code></pre>
<p>These boxed function pointers provide the callbacks that will be called when the increment and decrement buttons are pressed.</p>
<h3 id="custom-modifiers"><a class="header" href="#custom-modifiers">Custom modifiers</a></h3>
<p>Next we'll need to add some custom modifiers so the user can configure these callbacks. To do this we can define a trait and implement it on <code>Handle&lt;'_, Counter&gt;</code>:</p>
<pre><code class="language-rust">pub trait CounterModifiers {
    fn on_increment&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self;
    fn on_decrement&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self;
}</code></pre>
<p>We can use the <code>modify()</code> method on <code>Handle</code> to directly set the callbacks when implementing the modifiers:</p>
<pre><code class="language-rust">impl&lt;'a&gt; CounterModifiers for Handle&lt;'a, Counter&gt; {
    fn on_increment&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self {
        self.modify(|counter| counter.on_increment = Some(Box::new(callback)))
    }

    fn on_decrement&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self {
        self.modify(|counter| counter.on_decrement = Some(Box::new(callback)))
    }
}</code></pre>
<h3 id="internal-event-handling"><a class="header" href="#internal-event-handling">Internal event handling</a></h3>
<p>Unfortunately we can't just call these callbacks from the action callback of the buttons. Instead we'll need to emit some internal events which the counter can receive, and then the counter can call the callbacks. Define an internal event enum for the counter like so:</p>
<pre><code class="language-rust">pub enum CounterEvent {
    Decrement,
    Increment,
}</code></pre>
<p>We can then use this internal event with the buttons:</p>
<pre><code class="language-rust">Button::new(
    cx, 
    |ex| ex.emit(CounterEvent::Decrement), 
    |cx| Label::new(cx, "Decrement")
)
.class("dec");

Button::new(
    cx, 
    |ex| ex.emit(CounterEvent::Increment), 
    |cx| Label::new(cx, "Increment")
)
.class("inc");</code></pre>
<p>Finally, we respond to these events in the <code>event()</code> method of the <code>View</code> trait for the <code>Counter</code>, calling the appropriate callback:</p>
<pre><code class="language-rust">impl View for Counter {
    fn event(&amp;mut self, cx: &amp;mut EventContext, event: &amp;mut Event) {
        event.map(|counter_event, meta| match counter_event{
            CounterEvent::Increment =&gt; {
                if let Some(callback) = &amp;self.on_increment {
                    (callback)(cx);
                }
            }

            CounterEvent::Decrement =&gt; {
                if let Some(callback) = &amp;self.on_decrement {
                    (callback)(cx);
                }
            }
        });
    }
}</code></pre>
<p>To recap, now when the user presses on one of the buttons, the button will emit an internal <code>CounterEvent</code>, which is then handled by the <code>Counter</code> view to call the appropriate callback, which the user can set using the custom modifiers we added using the <code>CounterModifiers</code> trait.</p>
<h2 id="step-6-using-the-custom-view"><a class="header" href="#step-6-using-the-custom-view">Step 6: Using the custom view</a></h2>
<p>Finally, we can use our custom view in the application:</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        cx.add_stylesheet(include_style!("src/style.css"))
            .expect("Failed to load stylesheet");

        AppData { count: 0 }.build(cx);

        Counter::new(cx, AppData::lens)
            .on_increment(|cx| cx.emit(AppEvent::Increment))
            .on_decrement(|cx| cx.emit(AppEvent::Decrement));
    })
    .title("Counter")
    .inner_size((400, 150))
    .run()
}
</code></pre>
<p>We pass it the <code>AppData::lens</code>, but the custom view can accept any lens to an <code>i32</code> value. We also provide it with callbacks that should trigger when the increment and decrement buttons are pressed. In this case the callbacks will emit <code>AppEvent</code> events to mutate the model data.</p>
<p>When we run our app now it will seem like nothing has changed. However, now that our counter is a component, we could easily add multiple counters all bound to the same data (or different data):</p>
<pre><code class="language-rust">fn main() {
    Application::new(|cx|{

        cx.add_stylesheet(include_style!("src/style.css"))
            .expect("Failed to load stylesheet");

        AppData { count: 0 }.build(cx);

        Counter::new(cx, AppData::count)
            .on_increment(|cx| cx.emit(AppEvent::Increment))
            .on_decrement(|cx| cx.emit(AppEvent::Decrement));
        Counter::new(cx, AppData::count)
            .on_increment(|cx| cx.emit(AppEvent::Increment))
            .on_decrement(|cx| cx.emit(AppEvent::Decrement));
        Counter::new(cx, AppData::count)
            .on_increment(|cx| cx.emit(AppEvent::Increment))
            .on_decrement(|cx| cx.emit(AppEvent::Decrement));
    })
    .title("Counter")
    .inner_size((400, 150))
    .run();
}
</code></pre>
<p align="center">
<img src="quickstart/img/component.png" alt="Vizia app with three counter components"/>
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="localizing-the-application"><a class="header" href="#localizing-the-application">Localizing the Application</a></h1>
<p>An important part of building a GUI is making sure the application is usable for different regions around the world. Vizia uses fluent to provide translatable text for an application.</p>
<h2 id="creating-fluent-files"><a class="header" href="#creating-fluent-files">Creating fluent files</a></h2>
<p>Fluent files provide a key-value store for translated text strings which vizia uses to localize text in an application.</p>
<p>Let's add two fluent (.ftl) files to our application. We'll call them the same name, <code>counter.ftl</code>, but place them within separate directories, <code>en-Us</code> and <code>es</code>, within a <code>resources</code> directory.</p>
<p>Your project folder structure should now look like this:</p>
<pre><code class="language-bash">.
├── Cargo.toml
├── .git
├── .gitignore
└── src
    ├── resources
    │   ├── en-US
    │   │   └── counter.ftl
    │   └── es
    │       └── counter.ftl
    ├── main.rs
    └── style.css
</code></pre>
<p><em>resources/en-US/counter.ftl</em></p>
<pre><code>inc = Increment
dec = Decrement
</code></pre>
<p><em>resources/es/counter.ftl</em></p>
<pre><code>inc = Incrementar
dec = Decrementar
</code></pre>
<h2 id="adding-translations-to-the-application"><a class="header" href="#adding-translations-to-the-application">Adding translations to the application</a></h2>
<pre><code class="language-rust">cx.add_translation(
    langid!("en-US"),
    include_str!("resources/en-US/counter.ftl").to_owned(),
);

cx.add_translation(
    langid!("es"),
    include_str!("resources/es/counter.ftl").to_owned(),
);</code></pre>
<h2 id="localizing-text"><a class="header" href="#localizing-text">Localizing text</a></h2>
<p>To localize the text in our application we use the <code>Localized</code> type within the labels of the buttons, passing the translation keys to the constructor:</p>
<pre><code class="language-rust">Button::new(cx, |cx| Label::new(cx, Localized::new("dec")));

Button::new(cx, |cx| Label::new(cx, Localized::new("inc")));</code></pre>
<p>When the application is run these <code>Localized</code> objects are replaced with the translated strings from the fluent files based on the system locale.</p>
<h2 id="testing-localization"><a class="header" href="#testing-localization">Testing localization</a></h2>
<p>The locale used for selecting translations is stored in a model called the <code>Environment</code>. By default the locale used for translations is set to the system locale, however, we can use an <code>EnvironmentEvent</code> to set the locale to a user-specified value. This is useful for testing the localization of an application.</p>
<pre><code class="language-rust">cx.emit(EnvironmentEvent::SetLocale(langid!("es")));</code></pre>
<p>If we run our app now we'll see that the text has been translated into Spanish. Because the buttons are set up to hug their content, the widths of the buttons have automatically updated to accommodate the slightly longer text strings.</p>
<p align="center">
<img src="quickstart/img/localization.png" alt="A counter application translated into spanish">
</p>
<p>Note that if you're following this tutorial on a machine where the system locale is already set to Spanish then you'll see the Spanish translations without needing to emit the <code>SetLocale</code> event. To see the English versions of the text replace the <code>"es"</code> with <code>"en-US"</code> when emitting the event.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-the-application-accessible"><a class="header" href="#making-the-application-accessible">Making the Application Accessible</a></h1>
<p>Making the application accessibility is about making it so that assistive technologies, such as a screen reader, can navigate and query the application.</p>
<p>Our application so far is actually already mostly accessible as the built-in views, such as the buttons, are already set up to be accessible. However, even though the built-in views are accessible, this does not mean the app is automatically accessible.</p>
<p>For the case of our counter, when the increment or decrement buttons are pressed, causing the count to change, a screen reader does not know to speak the current count to inform the user of the change. To account for this we can use something called a 'live region'.</p>
<p>A live region is a view which has changing content but is not itself interactive. In the counter application a label shows the current counter value. This label is not itself interactive but has content which changes, and so should be marked as a live region. This will cause, for example, a screen reader to announce the value when the count changes.</p>
<p>A view can be marked as a live region with the <code>live()</code> modifier:</p>
<pre><code class="language-rust">Label::new(cx, AppData::count)
    .class("count")
    .live(Live::Assertive);</code></pre>
<p>If we were to use our counter application with a screen reader enabled now, the count value would be spoken when either of the buttons are pressed.</p>
<!-- // Video here? -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-final-code"><a class="header" href="#the-final-code">The Final Code</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<pre><code class="language-rust">use vizia::prelude::*;

// Define the application data
#[derive(Lens)]
pub struct AppData {
    count: i32,
}

// Define events for mutating the application data
pub enum AppEvent {
    Increment,
    Decrement,
}

// Mutate application data in response to events
impl Model for AppData {
    fn event(&amp;mut self, cx: &amp;mut EventContext, event: &amp;mut Event) {
        event.map(|app_event, meta| match app_event {
            AppEvent::Decrement =&gt; self.count -= 1,
            AppEvent::Increment =&gt; self.count += 1,
        });
    }
}

// Define a custom view for the counter
pub struct Counter {
    on_increment: Option&lt;Box&lt;dyn Fn(&amp;mut EventContext)&gt;&gt;,
    on_decrement: Option&lt;Box&lt;dyn Fn(&amp;mut EventContext)&gt;&gt;,
}

impl Counter {
    pub fn new&lt;L&gt;(cx: &amp;mut Context, lens: L) -&gt; Handle&lt;Self&gt;
    where
        L: Lens&lt;Target = i32&gt;
    {
        Self {
            on_decrement: None,
            on_increment: None,
        }.build(cx, |cx|{
            HStack::new(cx, |cx|{
                Button::new(cx, |cx| Label::new(cx, Localized::new("dec")))
                    .on_press(|ex| ex.emit(CounterEvent::Decrement))
                    .class("dec");

                Button::new(cx, |cx| Label::new(cx, Localized::new("inc")))
                    .on_press(|ex| ex.emit(CounterEvent::Increment))
                    .class("inc");
                
                Label::new(cx, lens)
                    .class("count")
                    .live(Live::Assertive);
            })
            .class("row");
        })
    }
}

// Internal events
pub enum CounterEvent {
    Decrement,
    Increment,
}

// Handle internal events
impl View for Counter {
    fn event(&amp;mut self, cx: &amp;mut EventContext, event: &amp;mut Event) {
        event.map(|counter_event, meta| match counter_event{
            CounterEvent::Increment =&gt; {
                if let Some(callback) = &amp;self.on_increment {
                    (callback)(cx);
                }
            }

            CounterEvent::Decrement =&gt; {
                if let Some(callback) = &amp;self.on_decrement {
                    (callback)(cx);
                }
            }
        });
    }
}

// Custom modifiers
pub trait CounterModifiers {
    fn on_increment&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self;
    fn on_decrement&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self;
}

// Implement custom modifiers
impl&lt;'a&gt; CounterModifiers for Handle&lt;'a, Counter&gt; {
    fn on_increment&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self {
        self.modify(|counter| counter.on_increment = Some(Box::new(callback)))
    }

    fn on_decrement&lt;F: Fn(&amp;mut EventContext) + 'static&gt;(self, callback: F) -&gt; Self {
        self.modify(|counter| counter.on_decrement = Some(Box::new(callback)))
    }
}

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        cx.add_stylesheet(include_style!("src/style.css")).expect("Failed to load stylesheet");

        cx.add_translation(
            langid!("en-US"),
            include_str!("resources/en-US/counter.ftl").to_owned(),
        );

        cx.add_translation(
            langid!("es"),
            include_str!("resources/es/counter.ftl").to_owned(),
        );

        // Uncomment to test with spanish locale.
        // If system locale is already Spanish, replace "es" with "en-US".
        // cx.emit(EnvironmentEvent::SetLocale(langid!("es")));

        // Build model data into the application
        AppData { count: 0 }.build(cx);

        // Add the custom counter view and bind to the model data
        Counter::new(cx, AppData::count)
            .on_increment(|cx| cx.emit(AppEvent::Increment))
            .on_decrement(|cx| cx.emit(AppEvent::Decrement));
    })
    .title("Counter")
    .inner_size((400, 150))
    .run()
}</code></pre>
<h2 id="css"><a class="header" href="#css">CSS</a></h2>
<pre><code class="language-css">.row {
    child-space: 1s;
    col-between: 20px;
}

button {
    border-width: 0px;
}

button.dec {
    background-color: rgb(170, 50, 50);
}

button.inc {
    background-color: rgb(50, 170, 50);
}

label.count {
    child-space: 1s;
    border-width: 1px;
    border-color: #808080;
    border-radius: 4px;
    width: 50px;
    height: 32px;
}
</code></pre>
<h2 id="fluent"><a class="header" href="#fluent">Fluent</a></h2>
<p><em>resources/en-US/counter.ftl</em></p>
<pre><code class="language-ftl">inc = Increment
dec = Decrement
</code></pre>
<p><em>resources/es/counter.ftl</em></p>
<pre><code class="language-ftl">inc = Incrementar
dec = Decrementar
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-an-application-1"><a class="header" href="#creating-an-application-1">Creating an Application</a></h1>
<p>The first step to building a GUI with vizia is to create an application. Creating a new application creates a main window and a <a href="https://docs.vizia.dev/vizia/context/struct.Context.html"><code>context</code></a>. Views declared within the closure passed to <code>Application::new()</code> are added to the context and rendered into the main window.</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        // Content goes here
    })
    .run()   
}</code></pre>
<p>Calling <code>run()</code> on the <code>Application</code> causes the program to enter the event loop and for the main window to display.</p>
<p><img src="application/./img/application.png" alt="An empty vizia application main window" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-windows"><a class="header" href="#multiple-windows">Multiple Windows</a></h1>
<p>While an application provides a default main window, additional windows can be created with the <a href="https://docs.vizia.dev/vizia_winit/window/struct.Window.html"><code>Window</code></a> view:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        // Main window content

        Window::new(cx, |cx| {
            // Secondary window content
        });
    })
    .run()
}
</code></pre>
<p>Windows, like other views, are built into the view tree. Therefore, they can access data in models further up the tree from them, and if the containing view is destroyed the window is closed.</p>
<p>A <a href="application/../binding/conditional_views.html">binding view</a> can be used to a conditionally create windows:</p>
<pre><code class="language-rust">Binding::new(cx, AppData::show_window, |cx, show_subwindow| {
    if show_subwindow.get(cx) {
        Window::new(cx, |cx| {
            
        })
        .on_close(|cx| {
            cx.emit(AppEvent::WindowClosed);
        });
    }
});</code></pre>
<p>Here we've used the <a href="https://docs.vizia.dev/vizia_winit/window_modifiers/trait.WindowModifiers.html#tymethod.on_close"><code>on_close</code></a> window modifier to reset the app state when the window is closed by the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-window-properties"><a class="header" href="#modifying-window-properties">Modifying Window Properties</a></h1>
<p>The properties of a window can be changed using <a href="https://docs.vizia.dev/vizia_winit/window_modifiers/trait.WindowModifiers.html">window modifiers</a>. For the main window, these modifiers are called on the application prior to calling <code>run()</code>.</p>
<p>For example, the <code>title()</code> and <code>inner_size()</code> window modifiers can be used to set the title and size of the window respectively.</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

    })
    .title("My Awesome Application")
    .inner_size((400, 200))
    .run()
}</code></pre>
<p><img src="application/./img/window_modifiers.png" alt="A window with the title &#39;My Awesome Application&#39;" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-views-1"><a class="header" href="#adding-views-1">Adding views</a></h1>
<p>Views are the building bocks of a vizia GUI and are used to visually present <a href="views/./models.html">model data</a> and to act as controls which, when interacted with, send events to mutate model data.</p>
<p>We'll learn more about models and events in the following sections.</p>
<h2 id="declaring-views"><a class="header" href="#declaring-views">Declaring views</a></h2>
<p>For example, we can declare a <code>Label</code> view to display a text string:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        Label::new(cx, "Hello World");
    })
    .inner_size((400, 200))
    .run()
}</code></pre>
<p><img src="views/./img/declaring_views.png" alt="A label view" /></p>
<p>The first argument to the <code>new()</code> method of the label is a mutable reference to <code>Context</code>, shortened to <code>cx</code>. This allows the view to build itself into the application and is passed from view to view.</p>
<h2 id="composing-views-1"><a class="header" href="#composing-views-1">Composing views</a></h2>
<p>Composition of views is achieved through container views, which typically take a closure which allows us to build child views within it. Some container views may arrange their content in a particular way.</p>
<p>For example, the <code>VStack</code> container view will arrange its contents into a vertical column:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        
        VStack::new(cx, |cx|{    
            Label::new(cx, "Hello");
            Label::new(cx, "World");
        });
    })
    .inner_size((400, 100))
    .run()
}</code></pre>
<p><img src="views/./img/composing_views.png" alt="" /></p>
<p>Composing views together forms a tree, where each view has a single parent and zero or more children. For example, for the code above the view tree can be depicted with the following diagram:</p>
<p><img src="views/./img/basic_tree.svg" alt="Diagram of a basic view tree depicting a Window view with a child HStack view with two child Label views." /></p>
<p>The Window is the <em>parent</em> of the VStack, while the VStack is the <em>parent</em> of both the Labels. Therefore, the Window is an <em>ancestor</em> of the Labels and the Labels are <em>descendants</em> of the window. This terminology is relevant when writing CSS style rules, which we'll cover later in this guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mofiying-views"><a class="header" href="#mofiying-views">Mofiying Views</a></h1>
<p>Modifiers are used to customize the appearance and behaviour of views in a declarative way. Many of the built-in modifiers in Vizia can be applied to any View, which includes built-in views as well as user-defined views.</p>
<h2 id="customize-a-view-with-a-modifier"><a class="header" href="#customize-a-view-with-a-modifier">Customize a view with a modifier</a></h2>
<p>Modifiers are functions which are called on a <a href="https://docs.vizia.dev/vizia/view/struct.Handle.html"><code>Handle</code></a>, which is returned by the constructor of all views. Applying modifiers to a view changes the properties of a view without rebuilding it. For example, we can use the <code>background_color()</code> modifier to set the background color of a label view:</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .background_color(Color::rgb(255, 0, 0));</code></pre>
<p><img src="views/./img/modifier.png" alt="A label with a background color modifier" /></p>
<p>Multiple modifiers can be chained together to acheieve more complex view configuration.</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .width(Pixels(200.0))
    .border_width(Pixels(1.0))
    .border_color(Color::black())
    .background_color(Color::rgb(200, 200, 200));</code></pre>
<p><img src="views/./img/modifiers.png" alt="A label with a multiple modifiers applied" /></p>
<h2 id="view-specific-modifiers-1"><a class="header" href="#view-specific-modifiers-1">View specific modifiers</a></h2>
<p>Some views have modifiers which are specific to that view type. For example, the <code>Slider</code> view has a modifier for setting the slider <code>range</code>:</p>
<pre><code class="language-rust">Slider::new(cx, AppData::value)
    .range(0.0..100.0);</code></pre>
<p>View specific modifiers can still be combined with regular modifiers, and the order doesn't matter. Both of these produce the same result:</p>
<pre><code class="language-rust">Slider::new(cx, AppData::value)
    .range(0.0..100.0)
    .width(Pixels(200.0));</code></pre>
<pre><code class="language-rust">Slider::new(cx, AppData::value)
    .width(Pixels(200.0))
    .range(0.0..100.0);</code></pre>
<h2 id="modifier-bindings-1"><a class="header" href="#modifier-bindings-1">Modifier bindings</a></h2>
<p>Many modifiers also accept a lens as well as a value. When a lens is supplied to a modifier, a binding is set up which will update the modified property when the bound to model data changes. For example:</p>
<pre><code class="language-rust">#[derive(Lens)]
pub struct AppData {
    color: Color,
}

...

Label::new(cx, "Hello World")
    .background_color(AppData::color);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-view-modifiers"><a class="header" href="#custom-view-modifiers">Custom View Modifiers</a></h1>
<p>To create a set of custom view modifiers, first declare a trait with the desired modifier functions. The modifier functions must take <code>self</code> by value and return <code>Self</code>.</p>
<pre><code class="language-rust">pub trait CustomModifiers:  {
    fn title(self) -&gt; Self;
}</code></pre>
<p>Next, we can implement the custom modifiers for all views like so:</p>
<pre><code class="language-rust">impl&lt;'a, V: View&gt; CustomModifiers for Handle&lt;'a, V&gt; {
    fn title(self) -&gt; Self {
        self.font_size(24.0).font_weight(FontWeightKeyword::Bold)
    }
}</code></pre>
<p>Sometimes it may be more appropriate to implement the custom modifiers for specific views. For example, we can implement the custom modifiers just the <code>Label</code> view like so:</p>
<pre><code class="language-rust">impl&lt;'a&gt; CustomModifiers for Handle&lt;'a, Label&gt; {
    fn title(self) -&gt; Self {
        self.font_size(24.0).font_weight(FontWeightKeyword::Bold)
    }
}</code></pre>
<p>As long as <code>CustomModifiers</code> is imported we can then use the custom <code>title()</code> modifier like any other modifier on a label:</p>
<pre><code class="language-rust">Label::new("Some Kind of Title").title();</code></pre>
<p><img src="views/./img/custom_modifiers.png" alt="A label with a custom modifier" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="models"><a class="header" href="#models">Models</a></h1>
<p>Application data in Vizia is stored in models. Views can then bind to the data in these models in order to react to changes in the data.</p>
<h2 id="declaring-models"><a class="header" href="#declaring-models">Declaring Models</a></h2>
<p>A model definition can be any type, typically a struct, which implements the <code>Model</code> trait:</p>
<pre><code class="language-rust">pub struct Person {
    pub name: String,
    pub email: String,
}

impl Model for Person {}</code></pre>
<h2 id="building-models"><a class="header" href="#building-models">Building Models</a></h2>
<p>A model definition can be built into the view tree with the <code>build()</code> method:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        Person {
            name: String::from("John Doe"),
            email: String::from("john.doe@company.com"),
        }.build(cx);

        HStack::new(cx, |cx|{
            Label::new(cx, "Hello");
            Label::new(cx, "World");
        });
    })
    .run();
}
</code></pre>
<p>This builds the model data into the tree, in this case at the root <code>Window</code>.</p>
<p>Internally, Vizia enforces a separation between views and models by storing them separately. However, for processes like event propagation, models can be thought of as existing within the tree, with an associated parent view.</p>
<p>The model-view tree for the above code can be depicted with the following diagram:</p>
<p><img src="models/../../img/basic_tree_model.svg" alt="Diagram of a basic model-view tree depicting a Window view, with an associated AppData model, and with a child HStack view with two child Label views." /></p>
<p>If the <code>AppData</code> had been built within the contents of the <code>HStack</code>, then the model would be associated with the <code>HStack</code> rather than the <code>Window</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment"><a class="header" href="#environment">Environment</a></h1>
<p>The <code>Environment</code> is a built-in model used to specify system specific application data, such as the current system locale and current system theme preference, which can then be used by any view in the application.</p>
<p>For example, we can bind to the locale and conditionally change the properties of a view depending on the selected language:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx| {
        Binding::new(cx, Environment::locale, |cx, locale| {
            match locale.get(cx).to_string().as_ref() {
                "en-US" =&gt; {
                    Element::new(cx).background_color(Color::from("#006847"));
                }

                "fr" =&gt; {
                    Element::new(cx).background_color(Color::from("#004768"));
                }

                _ =&gt; {}
            }
        });
    })
    .run()
}</code></pre>
<p>// Image here</p>
<p>The above example has an <code>Element</code> which will change color depending on the locale between <code>en-US</code> (US English) and <code>fr</code> (french).</p>
<p>By default the environment will use values specified by the system, such as the system specified language, but we can override these values with an environment event.</p>
<p>For example, we can toggle between two locales with a pair of checkboxes:</p>
<pre><code class="language-rust">use vizia::prelude::*;

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx| {
        cx.emit(EnvironmentEvent::SetLocale("en-US".parse().unwrap()));

        HStack::new(cx, |cx| {
            Checkbox::new(cx, Environment::locale.map(|locale| {
                    locale.to_string() == "en-US"
                }))
                .on_toggle(|cx| {
                    cx.emit(EnvironmentEvent::SetLocale("en-US".parse().unwrap()))
                });
            Label::new(cx, "English");

            Checkbox::new(cx, Environment::locale.map(|locale| {
                    locale.to_string() == "fr"
                }))
                .on_toggle(|cx| {
                    cx.emit(EnvironmentEvent::SetLocale("fr".parse().unwrap()))
                });
                .left(Pixels(10.0));
            Label::new(cx, "French");
        })
        .space(Pixels(10.0))
        .child_top(Stretch(1.0))
        .child_bottom(Stretch(1.0))
        .col_between(Pixels(5.0))
        .height(Auto);

        Binding::new(cx, Environment::locale, |cx, locale| {
            match locale.get(cx).to_string().as_ref() {
                "en-US" =&gt; {
                    Element::new(cx).background_color(Color::from("#006847"));
                }

                "fr" =&gt; {
                    Element::new(cx).background_color(Color::from("#004768"));
                }

                _ =&gt; {}
            }
        });
    })
    .run()
}</code></pre>
<p>// Image here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-binding"><a class="header" href="#data-binding">Data Binding</a></h1>
<p>Data binding is the concept of linking model data to views, so that when the model data is changed, the views observing this data update automatically in response. Therefore, it is data binding which provides the mechanism for reactivity in Vizia.</p>
<p>In Vizia, data binding is achieved through the use of lenses. A lens is an object which allows you to <em>select</em> some part of a model and inspect its value. These lens objects are then used to form a binding between views and these parts of the model, updating when only these specific parts have changed.</p>
<h2 id="lenses"><a class="header" href="#lenses">Lenses</a></h2>
<p>The <code>Lens</code> derive macro can be used to generate a lens for each field of a struct. These lenses can then be used to transform a reference to the struct into a reference to each of its fields. The generated lenses are given the same name as the field and placed in a module with the same name as the struct. For example, given the following definition of some model data:</p>
<pre><code class="language-rust">#[derive(Lens)]
pub struct AppData {
    color: Color,
}

impl Model for AppData {}</code></pre>
<p>A lens to the <code>color</code> field of the <code>AppData</code> struct is generated as <code>AppData::color</code>.</p>
<h2 id="property-binding"><a class="header" href="#property-binding">Property Binding</a></h2>
<p>We can then use this lens with the <code>background_color</code> modifier of a view to set up a binding, so that when the data changes the background color is updated. Passing lenses to modifiers is known as <em>property binding</em>.</p>
<pre><code class="language-rust">#[derive(Lens)]
pub struct AppData {
    color: Color,
}

impl Model for AppData {}

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        Label::new(cx, "Hello Vizia").background_color(AppData::color);
    }).run()
}</code></pre>
<h2 id="view-binding"><a class="header" href="#view-binding">View Binding</a></h2>
<p>Some views accept a lens as an input. When provided a lens, the view sets up a binding to the data. For example, the <code>Label</code> view accepts a lens to any type which implements <code>ToString</code>:</p>
<pre><code class="language-rust">#[derive(Lens)]
pub struct Person {
    pub name: String,
}

impl Model for Person {}

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{
        Label::new(cx, Person::name);
    })
    .run()    
}</code></pre>
<p>When the <code>name</code> field changes, the text of the label updates to show the new value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-data-trait"><a class="header" href="#the-data-trait">The Data Trait</a></h1>
<p>When views bind to model data the <a href="binding/binding.html">binding system</a> must determine whether the data has changed. To do this it stores a copy of the data for each binding. To be able to compare the previous data to the new version, the data type must implement the <code>Data</code> trait.</p>
<p>Note that this is only required for the data types which are bound to. The model itself does not need to implement <code>Data</code> unless a view is to bind to the entire model and not just a field within.</p>
<p>Most simple types already implement the <code>Data</code> trait, but for custom types there is a derive macro that can be used as long as the field types also implement the <code>Data</code> trait:</p>
<pre><code class="language-rust">#[derive(Clone, Data)]
pub struct CustomData {
    text: String,
} </code></pre>
<p>The <code>Data</code> trait also requires that the type implements <code>Clone</code>. This is because when the binding system has determined the data has changed, it must replace its stored copy of the data with a new one so it can recompare on the next update cycle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lens-map"><a class="header" href="#lens-map">Lens Map</a></h1>
<p>The <code>map()</code> method on a lens can be used to derive data from the target of the lens. This is useful for when the lens target is not the right type for the binding, but a value of the correct type can be derived from it.</p>
<p>For example, let's say we have some string data representing a name in our model, but we only want to display the first letter within a label:</p>
<pre><code class="language-rust">use vizia::prelude::*;

#[derive(Lens)]
pub struct AppData {
    pub name: String,
}

impl Model for AppData {}

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        AppData {
            name: String::from("John Doe"),
        }.build(cx);

        Label::new(cx, AppData::name.map(|name| name.chars().nth(0).unwrap()));
    })
    .inner_size((400, 100))
    .run()
}</code></pre>
<blockquote>
<p>Note that in this example we're assuming that the string is not empty.</p>
</blockquote>
<img src="binding/../img/stylesheet.png" alt="" width="400"/>
<p>Now when the name field of the model changes the label will update to display the new first letter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-views"><a class="header" href="#conditional-views">Conditional Views</a></h1>
<p>The <code>Binding</code> view provides a way to explicitely control which parts of the view tree get rebuilt when some state changes, specifically anything within the content closure of a <code>Binding</code> view.</p>
<p>Because of this, a regular <code>if</code> statement can be used to conditionally rebuild views. In the following example, a label view is built into the tree when a boolean state is true, else the view is removed from the tree.</p>
<pre><code class="language-rust">use vizia::prelude::*;

#[derive(Lens)]
struct AppData {
    show_view: bool,
}

enum AppEvent {
    ToggleShowView,
}

impl Model for AppData {
    fn event(&amp;mut self, cx: &amp;mut Context, event: &amp;mut Event) {
        event.map(|app_event, _| match app_event {
            AppEvent::ToggleShowView =&gt; self.show_view ^= true,
        });
    }
}

fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        AppData {
            show_view: false,
        }.build(cx);

        Label::new(cx, "Show View")
            .on_press(|cx| cx.emit(AppEvent::ToggleShowView));
        
        Binding::new(cx, AppData::show_view, |cx, show|{
            if show.get(cx) {
                Label::new(cx, "Surprise!");
            }
        });
    })
    .inner_size((400, 100))
    .run()
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-nested-data"><a class="header" href="#binding-nested-data">Binding Nested Data</a></h1>
<p>Let's say we have the following application data structure:</p>
<pre><code class="language-rs">#[derive(Lens)]
pub struct AppData {
    nested: NestedData,
}

#[derive(Lens)]
pub struct NestedData {
    name: String,
}
</code></pre>
<p>Provided that both the parent and nested structures derive the <code>Lens</code> trait, we can use the <code>then()</code> lens modifier to produce a lens which targets the nested data:</p>
<pre><code class="language-rs">fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        AppData {
            nested: NestedData {
                name: String::from("John Doe"),
            },
        }.build(cx);

        Label::new(cx, AppData::nested.then(NestedData::name));
    })
    .inner_size((400, 100))
    .run()
}
</code></pre>
<p>If the nested data structure does not derive <code>Lens</code>, then the <code>map_ref()</code> modifier can be used:</p>
<pre><code class="language-rs">fn main() -&gt; Result&lt;(), ApplicationError&gt; {
    Application::new(|cx|{

        AppData {
            nested: NestedData {
                name: String::from("John Doe"),
            },
        }.build(cx);

        Label::new(cx, AppData::nested.map_ref(|nested| &amp;nested.name));
    })
    .inner_size((400, 100))
    .run()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Events are used to communicate actions to update model or view data.</p>
<p>Events propagate through the tree from origin to target, typically from the view which emits the event, up through the ancestors of the view, to the main window and through any models on the way.</p>
<h2 id="declaring-events-1"><a class="header" href="#declaring-events-1">Declaring Events</a></h2>
<p>An event contains a message which can be any type, but is typically an enum:</p>
<pre><code class="language-rust">use vizia::prelude::*;

pub struct AppData {
    name: String,
}

pub enum PersonEvent {
    UpdateName(String),
}</code></pre>
<h2 id="emitting-events-1"><a class="header" href="#emitting-events-1">Emitting Events</a></h2>
<p>Events are usually emitted in response to some action on a view. For example, a button takes an action and a view to display. When the button is pressed the action is triggered, emitting an event up the tree.</p>
<pre><code class="language-rust">use vizia::prelude::*;

pub enum AppEvent {
    UpdateName(String),
}

#[derive(Lens)]
pub struct AppData {
    pub name: String,
}

impl Model for Person {}

fn main() {
    Application::new(|cx| {
        AppData { 
            name: String::from("John Doe"),
        }.build(cx);

        Label::new(cx, Person::name);
        
        Button::new(
            cx,
            |cx| cx.emit(AppEvent::UpdateName(String::from("Rob Doe"))),
            |cx| Label::new(cx, "Update"),
        );
    })
    .inner_size((400, 100))
    .run();
}</code></pre>
<h2 id="handling-events-1"><a class="header" href="#handling-events-1">Handling Events</a></h2>
<p>Events are handled by views and models with the <code>event()</code> method of the <code>View</code> or <code>Model</code> traits.</p>
<pre><code class="language-rust">use vizia::prelude::*;

pub enum AppEvent {
    UpdateName(String),
}

#[derive(Lens)]
pub struct AppData {
    pub name: String,
}

impl Model for Person {
    fn event(cx: &amp;mut Context, event: &amp;mut Event) {
        event.map(|app_event, meta| match app_event {
            AppEvent::UpdateName(new_name) =&gt; {
                self.name = new_name.clone();
            }
        });
    }
}</code></pre>
<p>Calling <code>map()</code> on an event attempts to cast the event message to the specified type and calls the provided closure if it succeeds.</p>
<blockquote>
<p>Note that in the above  example the rust compiler is able to infer the message type from the match statement.</p>
</blockquote>
<p>The closure provides the message type and an <code>EventMeta</code>, which can be used to query the origin and target views of the event, or to consume the event to prevent it propagating further, for example:</p>
<pre><code class="language-rust">event.map(|person_event, meta| match person_event {
    AppEvent::UpdateName(new_name) =&gt; {
        self.name = new_name.clone();

        // Consume the event to stop it propagating
        meta.consume();
    }
});</code></pre>
<h2 id="event-propagation"><a class="header" href="#event-propagation">Event Propagation</a></h2>
<p>Events propagate through the view tree according to their specified <code>Propagation</code>. Using <code>cx.emit()</code> will produce an event which propagates <strong>up</strong> the tree from ancestor to ancestor.</p>
<p>To send an event directly to another view, there is <code>cx.emit_to(message, target)</code>, which takes a message as well as a target id.</p>
<!-- Events propagate through the view tree, and how an event propagates is specific to the event type. However, usually a platform event will propagate down the tree to the target view or model, and a user event will propagate up the tree to the target view or model. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="stylesheets"><a class="header" href="#stylesheets">Stylesheets</a></h1>
<p>Styling refers to modifying the visual properties of a view, such as its background, border, font, etc.</p>
<p>Previously it was shown how modifiers can be used to style views inline. However, it is also possible for multiple views to share the same styling through the use of Cascading Style Sheets (CSS).</p>
<p>Vizia can use CSS to apply style rules to multiple views simultaneously. A CSS string can be defined within a rust file as a constant, or within an external CSS file.</p>
<h2 id="adding-a-constant-stylesheet-string"><a class="header" href="#adding-a-constant-stylesheet-string">Adding a constant stylesheet string</a></h2>
<p>To add a stylesheet which is already a string in rust code, use the <code>add_stylesheet()</code> method on <code>Context</code>. For example:</p>
<pre><code class="language-rust">use vizia::prelude::*;

const STYLE: &amp;str = r#"
    element {
        background-color: red;
    }
"#

fn main() {
    Application::new(|cx|{
        
        cx.add_stylesheet(STYLE);
        
        Element::new(cx)
            .size(Pixels(100.0));
    })
}</code></pre>
<h2 id="adding-an-external-css-file"><a class="header" href="#adding-an-external-css-file">Adding an external CSS file</a></h2>
<p>To add a stylesheet which is defined in a separate <code>.css</code> file, use <code>add_stylesheet()</code> method with the <code>include_style!()</code> macro. For example:</p>
<pre><code class="language-css">/* style.css */
element {
    background-color: blue;
}
</code></pre>
<pre><code class="language-rust">/* main.rs */
use vizia::prelude::*;

fn main() {
    Application::new(|cx|{
        
        cx.add_stylesheet(include_style!("style.css"));
        
        Element::new(cx)
            .size(Pixels(100.0));
    })
}</code></pre>
<blockquote>
<p>External stylesheets can be hot-reloaded using the <code>F5</code> key while the application is running in debug mode.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rules--selectors"><a class="header" href="#rules--selectors">Rules &amp; Selectors</a></h1>
<p>Vizia currently supports a custom subset of the CSS standard. This section provides an overview and reference of the supported CSS selectors, selector combinators and pseudo-classes available in vizia.</p>
<h2 id="style-rules"><a class="header" href="#style-rules">Style Rules</a></h2>
<p>A typical style rule might look something like this:</p>
<pre><code class="language-css">hstack.one label {
    background-color: red;
    width: 30px;
}
</code></pre>
<p>The first part before the opening brace is called a <a href="styling/selectors.html#selectors">selector</a>, which determines which views the rule applies to, and the part inside the brackets are a list of properties and values to apply to the styling of matching views.</p>
<h2 id="selectors"><a class="header" href="#selectors">Selectors</a></h2>
<h3 id="basic-selectors"><a class="header" href="#basic-selectors">Basic Selectors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Selector</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td>Selects all views that have the given element name, e.g. <code>button</code> will select all <code>Button</code> views.</td></tr>
<tr><td>class</td><td>Sselects all views that have the given class name prefixed with a period, e.g. <code>.class-name</code> will match any view that has <code>class("class-name")</code>. A class name can be added to a view with the <code>class</code> style modifier. The <code>toggle_class</code> modifier can be used to conditionally add/remove a class from a view, typically with the use of a lens to a boolean.</td></tr>
<tr><td>ID</td><td>Selects views with the specified ID name, prefixed with a hash, e.g. <code>#id-name</code> will match the view that has <code>id("id-name")</code>.  An ID name can be added to a view with the <code>id</code> style modifier and must be a unique name.</td></tr>
<tr><td>universal</td><td>The universal selector, denoted with an asterisk, selects all views.</td></tr>
</tbody></table>
</div>
<h3 id="combinators"><a class="header" href="#combinators">Combinators</a></h3>
<p>Using combinators, we can combine selectors to select views based on their relationship to other views within the tree.</p>
<div class="table-wrapper"><table><thead><tr><th>Combinator</th><th>Description</th></tr></thead><tbody>
<tr><td>descendant</td><td>Selects views which match the selector after the space if they are descended from an view which matches the selector before the space. For example, <code>hstack label</code> will match any <code>Label</code> which has an <code>HStack</code> as an ancestor further up the tree.</td></tr>
<tr><td>child</td><td>Selects views which match the selector after the greater than character (<code>&gt;</code>) if they are the child of a view which matches the selector before the greater than character. For example, <code>hstack &gt; label</code> will match any <code>Label</code> which has an <code>HStack</code> as a parent.</td></tr>
<tr><td>subsquent-sibling</td><td>The subsequent-sibling combinator, denoted with a tilde (<code>~</code>), selects siblings. Given <code>A ~ B</code>, all views matching <code>B</code> will be selected if they are preceded by <code>A</code>, provided both <code>A</code> and <code>B</code> share the same parent.</td></tr>
<tr><td>next-sibling</td><td>The next-sibling combinator, denoted by the plus symbol (<code>+</code>), is similar to the subsequent-sibling. However, given <code>A + B</code>, it only matches <code>B</code> if <code>B</code> is immediately preceded by <code>A</code>, with both sharing the same parent.</td></tr>
</tbody></table>
</div>
<h3 id="pseudo-classes"><a class="header" href="#pseudo-classes">Pseudo-classes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Pseudo-class</th><th>Description</th></tr></thead><tbody>
<tr><td><code>:root</code></td><td>Selects the root window.</td></tr>
<tr><td><code>:hover</code></td><td>Selects the currently hovered view.</td></tr>
<tr><td><code>:checked</code></td><td>Selects any view which has been marked as checked. A view can be marked as checked with the <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.checked"><code>checked</code></a> style modifier.</td></tr>
<tr><td><code>:disabled</code></td><td>Selects any view which has been marked as disabled. A view can be marked as disabled with the <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.disabled"><code>disabled</code></a> style modifier.</td></tr>
<tr><td><code>:active</code></td><td>Selects any view which has been marked as active.</td></tr>
<tr><td><code>:focus</code></td><td>Selects the currently focused view.</td></tr>
<tr><td><code>:focus-visible</code></td><td>Selects the currently focused view if the view was focused via keyboard navigation.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="list-of-supported-style-properties"><a class="header" href="#list-of-supported-style-properties">List of supported style properties</a></h1>
<p>This section provides a list of the currently supported style properties in vizia. This excludes layout properties which are detailed in the <a href="styling/../layout/layout.html">layout section</a> of this guide.</p>
<p>For the corresponding modifier name, replace any hyphens with underscores. For example, <code>background-color</code> in CSS becomes the <code>background_color()</code> modifier in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Type</th><th>Initial Value</th><th>Inherited</th><th>Animatable</th></tr></thead><tbody>
<tr><td><code>backdrop-filter</code></td><td><code>Filter</code></td><td><code>none</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>background-color</code></td><td><code>Color</code></td><td><code>transparent</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>background-image</code></td><td><code>BackgroundImage</code></td><td><code>none</code></td><td>No</td><td>No</td></tr>
<tr><td><code>background-size</code></td><td><code>BackgroundSize</code></td><td><code>auto auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>blend-mode</code></td><td><code>BlendMode</code></td><td><code>normal</code></td><td>No</td><td>No</td></tr>
<tr><td><code>border</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>border-color</code></td><td><code>Color</code></td><td><code>transparent</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>border-style</code></td><td><code>BorderStyle</code></td><td><code>solid</code></td><td>No</td><td>No</td></tr>
<tr><td><code>border-width</code></td><td><code>LengthOrPercentage</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>caret-color</code></td><td><code>Color</code></td><td><code>transparent</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>clip-path</code></td><td><code>ClipPath</code></td><td><code>none</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>color</code></td><td><code>Color</code></td><td><code>transparent</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>corner-radius</code></td><td><code>CornerRadius</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>corner-top-left-radius</code></td><td><code>LengthOrPercentage</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>corner-top-right-radius</code></td><td><code>LengthOrPercentage</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>corner-bottom-left-radius</code></td><td><code>LengthOrPercentage</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>corner-bottom-right-radius</code></td><td><code>LengthOrPercentage</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>corner-shape</code></td><td><code>Rect&lt;CornerShape&gt;</code></td><td><code>round</code></td><td>No</td><td>No</td></tr>
<tr><td><code>corner-top-left-shape</code></td><td><code>CornerShape</code></td><td><code>round</code></td><td>No</td><td>No</td></tr>
<tr><td><code>corner-top-right-shape</code></td><td><code>CornerShape</code></td><td><code>round</code></td><td>No</td><td>No</td></tr>
<tr><td><code>corner-bottom-left-shape</code></td><td><code>CornerShape</code></td><td><code>round</code></td><td>No</td><td>No</td></tr>
<tr><td><code>corner-bottom-right-shape</code></td><td><code>CornerShape</code></td><td><code>round</code></td><td>No</td><td>No</td></tr>
<tr><td><code>cursor</code></td><td><code>CursorIcon</code></td><td><code>default</code></td><td>No</td><td>No</td></tr>
<tr><td><code>display</code></td><td><code>Display</code></td><td><code>flex</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>font-family</code></td><td><code>FontFamily</code></td><td></td><td>Yes</td><td>No</td></tr>
<tr><td><code>font-size</code></td><td><code>FontSize</code></td><td><code>16</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>font-slant</code></td><td><code>FontSlant</code></td><td><code>normal</code></td><td>Yes</td><td>No</td></tr>
<tr><td><code>font-weight</code></td><td><code>FontWidth</code></td><td><code>regular</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>font-width</code></td><td><code>FontWeight</code></td><td><code>normal</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>font-variation-settings</code></td><td><code>FontVariation</code></td><td><code>none</code></td><td>Yes</td><td></td></tr>
<tr><td><code>line-clamp</code></td><td><code>u32</code></td><td><code>1</code></td><td>No</td><td>No</td></tr>
<tr><td><code>opacity</code></td><td><code>f32</code></td><td><code>1.0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>outline</code></td><td>shorthand</td><td></td><td>No</td><td></td></tr>
<tr><td><code>outline-color</code></td><td><code>Color</code></td><td><code>transparent</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>outline-offset</code></td><td><code>LengthOrPercentage</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>outline-width</code></td><td><code>LengthOrPercentage</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>overflow</code></td><td><code>Overflow</code></td><td><code>visible</code></td><td>No</td><td>No</td></tr>
<tr><td><code>overflow-x</code></td><td><code>Overflow</code></td><td><code>visible</code></td><td>No</td><td>No</td></tr>
<tr><td><code>overflow-y</code></td><td><code>Overflow</code></td><td><code>visible</code></td><td>No</td><td>No</td></tr>
<tr><td><code>pointer-events</code></td><td><code>PointerEvents</code></td><td><code>auto</code></td><td>No</td><td>No</td></tr>
<tr><td><code>rotate</code></td><td><code>Angle</code></td><td><code>0</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>scale</code></td><td><code>Scale</code></td><td><code>1</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>selection-color</code></td><td><code>Color</code></td><td><code>transparent</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>shadow</code></td><td><code>Shadow</code></td><td></td><td>No</td><td>Yes</td></tr>
<tr><td><code>text-align</code></td><td><code>TextAlign</code></td><td><code>left</code></td><td>No</td><td>No</td></tr>
<tr><td><code>text-decoration</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>text-decoration-line</code></td><td></td><td></td><td>Yes</td><td>No</td></tr>
<tr><td><code>text-overflow</code></td><td></td><td><code>clip</code></td><td>No</td><td>No</td></tr>
<tr><td><code>text-wrap</code></td><td><code>bool</code></td><td><code>true</code></td><td>No</td><td>No</td></tr>
<tr><td><code>transform</code></td><td><code>Transform</code></td><td></td><td>No</td><td>Yes</td></tr>
<tr><td><code>transform-origin</code></td><td><code>Position</code></td><td></td><td>No</td><td>Yes</td></tr>
<tr><td><code>transition</code></td><td></td><td></td><td></td><td></td></tr>
<tr><td><code>translate</code></td><td><code>Translate</code></td><td></td><td>No</td><td>Yes</td></tr>
<tr><td><code>visibility</code></td><td><code>Visibility</code></td><td></td><td>No</td><td>No</td></tr>
<tr><td><code>z-index</code></td><td><code>i32</code></td><td><code>0</code></td><td>No</td><td>No</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="transitions"><a class="header" href="#transitions">Transitions</a></h1>
<p>Transitions are animations for style rule properties which apply when a view matches that rule. Transitions are specified with the <code>transition</code> CSS property, and you must specify the property to animate and the duration of the animation, and optionally any delay on the animation and a timing function.</p>
<p>For example, we can create a transition for the background color of a view when hovered:</p>
<pre><code class="language-rust">use vizia::prelude::*;

const STYLE: &amp;str = r#"
    .my_view {
        background-color: red;
    }

    .my_view:hover {
        background-color: blue;
        transition: background-color 100ms;
    }
"#;

fn main () {
    Application::new(|cx|{
        Element::new(cx)
            .class("my_view")
            .size(Pixels(200.0));
    })
    .run();
}
</code></pre>
<p>Note that the transition only occurs when the cursor hovers the element and not when the cursor leaves the element (unless the transition did not complete when the cursor left). This is because the transition has been specified on the <code>:hover</code> state of the element, and so the background color will transition when going <em>to</em> this state.</p>
<p>To transition back again, we need to specify a transition on the non-hover state as well:</p>
<pre><code class="language-css">.my_view {
    background-color: red;
    transition: background-color 100ms;
}

.my_view:hover {
    background-color: blue;
    transition: background-color 100ms;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layer-properties"><a class="header" href="#layer-properties">Layer Properties</a></h1>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p>The visibility property shows or hides a view without affecting its layout.</p>
<pre><code class="language-css">/* Keyword values */
visibility: visible;
visibility: hidden;
</code></pre>
<h2 id="opacity"><a class="header" href="#opacity">Opacity</a></h2>
<p>The <code>opacity</code> property determines how much of the content behind a view can be seen.</p>
<pre><code class="language-css">opacity: 0.9;

opacity: 90%;
</code></pre>
<h2 id="blend-mode"><a class="header" href="#blend-mode">Blend mode</a></h2>
<p>The <code>blend-mode</code> property determines how a view's content should blend with the content of the view's behind it.</p>
<pre><code class="language-css">/* Keyword values */
blend-mode: normal;
blend-mode: multiply;
blend-mode: screen;
blend-mode: overlay;
blend-mode: darken;
blend-mode: lighten;
blend-mode: color-dodge;
blend-mode: color-burn;
blend-mode: hard-light;
blend-mode: soft-light;
blend-mode: difference;
blend-mode: exclusion;
blend-mode: hue;
blend-mode: saturation;
blend-mode: color;
blend-mode: luminosity;
blend-mode: plus;
</code></pre>
<h2 id="z-index"><a class="header" href="#z-index">Z-Index</a></h2>
<p>The <code>z-index</code> property determines the z-order of a view and its descendants. Overlapping elements with a larger z-index cover those with a smaller one.</p>
<h2 id="overflow"><a class="header" href="#overflow">Overflow</a></h2>
<p>The overflow shorthand property sets the desired behavior when content does not fit in the view's bounds in the horizontal and/or vertical direction.</p>
<pre><code class="language-css">/* Keyword values */
overflow: visible;
overflow: hidden;
overflow: hidden visible;
</code></pre>
<p>The overflow can be set for each axis using the <code>overflow-x</code> and <code>overflow-y</code> properties.</p>
<h2 id="clip-path"><a class="header" href="#clip-path">Clip Path</a></h2>
<p>The <code>clip-path</code> property creates a clipping region that sets what part of an element should be shown. Parts that are inside the region are shown, while those outside are hidden.</p>
<pre><code class="language-css">/* Keyword values */
clip-path: auto;

/* &lt;basic-shape&gt; values */
clip-path: inset(100px 50px);
clip-path: rect(5px 5px 160px 145px);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background-properties"><a class="header" href="#background-properties">Background Properties</a></h1>
<h2 id="background-color"><a class="header" href="#background-color">Background Color</a></h2>
<p>Sets the <code>background-color</code> of a view.</p>
<pre><code class="language-css">/* Keyword values */
background-color: red;
background-color: indigo;

/* Hexadecimal value */
background-color: #bbff00; /* Fully opaque */
background-color: #bf0; /* Fully opaque shorthand */
background-color: #11ffee00; /* Fully transparent */
background-color: #1fe0; /* Fully transparent shorthand */
background-color: #11ffeeff; /* Fully opaque */
background-color: #1fef; /* Fully opaque shorthand */

/* RGB value */
background-color: rgb(255 255 128); /* Fully opaque */
background-color: rgb(117 190 218 / 50%); /* 50% transparent */

/* HSL value */
background-color: hsl(50 33% 25%); /* Fully opaque */
background-color: hsl(50 33% 25% / 75%); /* 75% opaque, i.e. 25% transparent */

</code></pre>
<p>The background color is rendered behind any <a href="styling/background.html#background-image"><code>background-image</code></a> but will show through any transparency in the image.</p>
<h2 id="background-image"><a class="header" href="#background-image">Background Image</a></h2>
<p>The <code>background-image</code> property sets one or more background images on a view.</p>
<pre><code class="language-css">/* single image */
background-image: linear-gradient(black, white);
background-image: url("cat-front.png");

/* multiple images */
background-image: radial-gradient(circle, #0000 45%, #000f 48%),
  radial-gradient(ellipse farthest-corner, #fc1c14 20%, #cf15cf 80%);
</code></pre>
<h2 id="background-size"><a class="header" href="#background-size">Background Size</a></h2>
<p>The <code>background-size</code> property sets the size of the view's background image. The image can be left to its natural size, stretched, or constrained to fit the available space.</p>
<pre><code class="language-css">/* Keyword values */
background-size: cover;
background-size: contain;

/* One-value syntax */
/* the width of the image (height becomes 'auto') */
background-size: 50%;
background-size: 3.2em;
background-size: 12px;
background-size: auto;

/* Two-value syntax */
/* first value: width of the image, second value: height */
background-size: 50% auto;
background-size: 3em 25%;
background-size: auto 6px;
background-size: auto auto;

/* Multiple backgrounds */
background-size: auto, auto; /* Not to be confused with `auto auto` */
background-size: 50%, 25%, 25%;
background-size: 6px, auto, contain;
</code></pre>
<h2 id="background-position"><a class="header" href="#background-position">Background Position</a></h2>
<p>The <code>background-position</code> CSS property sets the initial position for each background image.</p>
<pre><code class="language-css">/* Keyword values */
background-position: top;
background-position: bottom;
background-position: left;
background-position: right;
background-position: center;

/* &lt;percentage&gt; values */
background-position: 25% 75%;

/* &lt;length&gt; values */
background-position: 0 0;
background-position: 1cm 2cm;
background-position: 10ch 8em;

/* Multiple images */
background-position: 0 0, center;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border-properties"><a class="header" href="#border-properties">Border Properties</a></h1>
<h2 id="border-shorthand"><a class="header" href="#border-shorthand">Border (shorthand)</a></h2>
<p>The border property is shorthand for <a href="styling/border.html#border-width"><code>border-width</code></a>, <a href="styling/border.html#border-style"><code>border-style</code></a>, and <a href="styling/border.html#border-color"><code>border-color</code></a>, and sets the border of a view.</p>
<pre><code class="language-css">/* style */
border: solid;

/* width | style */
border: 2px dashed;

/* style | color */
border: solid red;

/* width | style | color */
border: 5px dashed green;
</code></pre>
<h2 id="border-width"><a class="header" href="#border-width">Border Width</a></h2>
<p>The <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.border_width"><code>border-width</code></a> property sets the width of a view's border.</p>
<pre><code class="language-css">border-width: 5px;
border-width: 20%;
</code></pre>
<h2 id="border-style"><a class="header" href="#border-style">Border Style</a></h2>
<p>The <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.border_style"><code>border-style</code></a> property sets the style of a view's border.</p>
<pre><code class="language-css">border-style: none;
border-style: solid;
border-style: dashed;
border-style: dotted;
</code></pre>
<h2 id="border-color"><a class="header" href="#border-color">Border Color</a></h2>
<p>The <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.border_color"><code>border-color</code></a> property sets the color of a view's border.</p>
<pre><code class="language-css">border-color: red;
border-color: #566;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="corner-properties"><a class="header" href="#corner-properties">Corner Properties</a></h1>
<h2 id="corner-radius"><a class="header" href="#corner-radius">Corner Radius</a></h2>
<p>The <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.corner_radius"><code>corner-radius</code></a> property rounds the corners of a view's outer border edge. You can set a single radius to make circular corners.</p>
<pre><code class="language-css">/* Radius is set for all 4 sides */
corner-radius: 10px;

/* top-left-and-bottom-right | top-right-and-bottom-left */
corner-radius: 10px 5%;

/* top-left | top-right-and-bottom-left | bottom-right */
corner-radius: 2px 4px 2px;

/* top-left | top-right | bottom-right | bottom-left */
corner-radius: 1px 0 3px 4px;
</code></pre>
<p>Individual corner radii can be set using the <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.corner_top_left_radius"><code>corner-top-left-radius</code></a>, <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.corner_top_right_radius"><code>corner-top-right-radius</code></a>, <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.corner_bottom_left_radius"><code>corner-bottom-left-radius</code></a>, and <a href="https://docs.vizia.dev/vizia/modifiers/trait.StyleModifiers.html#method.corner_bottom_right_radius"><code>corner-bottom-right-radius</code></a> properties.</p>
<p>A circular shape can be achieved by setting the corner radius to 50%:</p>
<pre><code class="language-css">corner-radius: 50%;
</code></pre>
<h2 id="corner-shape"><a class="header" href="#corner-shape">Corner Shape</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effects"><a class="header" href="#effects">Effects</a></h1>
<h2 id="shadows"><a class="header" href="#shadows">Shadows</a></h2>
<p>The <code>shadow</code> property adds shadow effects around a view's frame. You can set multiple shadows separated by commas. A shadow is described by X and Y offsets relative to the element, blur and spread radius, and color.</p>
<pre><code class="language-css">/* A color and two length values */
/* &lt;color&gt; | &lt;length&gt; | &lt;length&gt; */
shadow: red 60px -16px;

/* Three length values and a color */
/* &lt;length&gt; | &lt;length&gt; | &lt;length&gt; | &lt;color&gt; */
shadow: 10px 5px 5px black;

/* Four length values and a color */
/* &lt;length&gt; | &lt;length&gt; | &lt;length&gt; | &lt;length&gt; | &lt;color&gt; */
shadow: 2px 2px 2px 1px rgb(0 0 0 / 20%);

/* inset, length values, and a color */
/* &lt;inset&gt; | &lt;length&gt; | &lt;length&gt; | &lt;color&gt; */
shadow: inset 5em 1em gold;

/* Any number of shadows, separated by commas */
shadow:
  3px 3px red inset,
  -1em 0 0.4em olive;
</code></pre>
<h2 id="backdrop-filter"><a class="header" href="#backdrop-filter">Backdrop Filter</a></h2>
<p>The <code>backdrop-filter</code> property allows you apply a blur effect to the area behind a view. Because it applies to everything behind the view, to see the effect the view or its background needs to be transparent or partially transparent.</p>
<pre><code class="language-css">backdrop-filter: blur(2px);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outline-properties"><a class="header" href="#outline-properties">Outline Properties</a></h1>
<h2 id="outline-shorthand"><a class="header" href="#outline-shorthand">Outline (shorthand)</a></h2>
<p>The <code>outline</code> property is shorthand for <a href="styling/outline.html#outline-width"><code>outline-width</code></a> and <a href="styling/outline.html#border-color"><code>outline-color</code></a>.</p>
<pre><code class="language-css">/* width | color */
outline: 2px red;
</code></pre>
<h2 id="outline-width"><a class="header" href="#outline-width">Outline Width</a></h2>
<p>The <code>outline-width</code> property sets the width of a view's outline.</p>
<pre><code class="language-css">outline-width: 5px;
outline-width: 20%;
</code></pre>
<h2 id="outline-offset"><a class="header" href="#outline-offset">Outline Offset</a></h2>
<p>The outline-offset property sets the amount of space between an outline and the edge or border of a view.</p>
<pre><code class="language-css">/* &lt;length&gt; values */
outline-offset: 3px;
</code></pre>
<h2 id="outline-color"><a class="header" href="#outline-color">Outline Color</a></h2>
<p>The <code>outline-color</code> property sets the color of a view's outline.</p>
<pre><code class="language-css">outline-color: red;
outline-color: #566;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-properties"><a class="header" href="#text-properties">Text Properties</a></h1>
<h2 id="font-family"><a class="header" href="#font-family">Font Family</a></h2>
<p>The <code>font-family</code> property specifies a prioritized list of one or more font family names and/or generic family names for the selected view.</p>
<pre><code class="language-css">/* A font family name and a generic family name */
font-family: "Gill Sans Extrabold", sans-serif;
font-family: "Goudy Bookletter 1911", sans-serif;

/* A generic family name only */
font-family: serif;
font-family: sans-serif;
font-family: monospace;
font-family: cursive;
font-family: fantasy;
</code></pre>
<h2 id="font-size"><a class="header" href="#font-size">Font Size</a></h2>
<p>The <code>font-size</code> property sets the size of the font.</p>
<pre><code class="language-css">/* &lt;absolute-size&gt; values */
font-size: xx-small;
font-size: x-small;
font-size: small;
font-size: medium;
font-size: large;
font-size: x-large;
font-size: xx-large;
font-size: xxx-large;

/* &lt;relative-size&gt; values */
font-size: smaller;
font-size: larger;

/* &lt;length&gt; values */
font-size: 12px;
</code></pre>
<h2 id="font-weight"><a class="header" href="#font-weight">Font Weight</a></h2>
<p>The <code>font-weight</code> property determines the weight (or boldness) of the font. The weights available depend on the <a href="styling/text.html#font-family"><code>font-family</code></a> that is currently set.</p>
<pre><code class="language-css">/* &lt;font-weight-absolute&gt; keyword values */
font-weight: normal;
font-weight: bold;

/* &lt;font-weight-absolute&gt; numeric values [1,1000] */
font-weight: 100;
font-weight: 200;
font-weight: 300;
font-weight: 400; /* normal */
font-weight: 500;
font-weight: 600;
font-weight: 700; /* bold */
font-weight: 800;
font-weight: 900;
</code></pre>
<h2 id="font-slant"><a class="header" href="#font-slant">Font Slant</a></h2>
<p>The <code>font-slant</code> property determines whether a font should be styled with a normal, italic, or oblique face from its <a href="styling/text.html#font-family"><code>font-family</code></a>.</p>
<pre><code class="language-css">font-slant: normal;
font-slant: italic;
font-slant: oblique;
font-slant: oblique 10deg;
</code></pre>
<h2 id="font-width"><a class="header" href="#font-width">Font Width</a></h2>
<p>The <code>font-width</code> property selects a normal, condensed, or expanded face from a font.</p>
<pre><code class="language-css">/* keyword values */
font-width: normal;
font-width: ultra-condensed;
font-width: extra-condensed;
font-width: condensed;
font-width: semi-condensed;
font-width: semi-expanded;
font-width: expanded;
font-width: extra-expanded;
font-width: ultra-expanded;
</code></pre>
<h2 id="font-variation-settings"><a class="header" href="#font-variation-settings">Font Variation Settings</a></h2>
<p>The <code>font-variation-settings</code> property provides low-level control over variable font characteristics by letting you specify the four letter axis names of the characteristics you want to vary along with their values.</p>
<pre><code class="language-css">/* Set values for variable font axis names */
font-variation-settings: "xhgt" 0.7;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transform-properties"><a class="header" href="#transform-properties">Transform Properties</a></h1>
<p>Transforms are a post-layout effect and therefore affect the rendering of a view but not its layout.</p>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<p>The <code>transform</code> property lets you rotate, scale, skew, or translate a view.</p>
<pre><code class="language-css">/* Function values */
transform: matrix(1, 2, 3, 4, 5, 6);
transform: rotate(0.5turn);
transform: rotateX(10deg);
transform: rotateY(10deg);
transform: translate(12px, 50%);
transform: translateX(2em);
transform: translateY(3in);
transform: scale(2, 0.5);
transform: scaleX(2);
transform: scaleY(0.5);
transform: skew(30deg, 20deg);
transform: skewX(30deg);
transform: skewY(1.07rad);
</code></pre>
<h2 id="transform-origin"><a class="header" href="#transform-origin">Transform Origin</a></h2>
<p>The <code>transform-origin</code> property determines the origin for a view's transformations.</p>
<pre><code class="language-css">/* One-value syntax */
transform-origin: 2px;
transform-origin: bottom;

/* x-offset | y-offset */
transform-origin: 3cm 2px;

/* x-offset-keyword | y-offset */
transform-origin: left 2px;

/* x-offset-keyword | y-offset-keyword */
transform-origin: right top;

/* y-offset-keyword | x-offset-keyword */
transform-origin: top right;
</code></pre>
<h2 id="translate"><a class="header" href="#translate">Translate</a></h2>
<p>The <code>translate</code> property allows you to specify translation transforms individually and independently of the <a href="styling/transform.html#transform"><code>transform</code></a> property.</p>
<pre><code class="language-css">/* Single values */
translate: 100px;
translate: 50%;

/* Two values */
translate: 100px 200px;
translate: 50% 105px;
</code></pre>
<h2 id="rotate"><a class="header" href="#rotate">Rotate</a></h2>
<p>The <code>rotate</code> property allows you to specify rotation transforms individually and independently of the <a href="styling/transform.html#transform"><code>transform</code></a> property.</p>
<pre><code class="language-css">/* Angle value */
rotate: 90deg;
rotate: 0.25turn;
rotate: 1.57rad;
</code></pre>
<h2 id="scale"><a class="header" href="#scale">Scale</a></h2>
<p>The <code>scale</code> property allows you to specify scale transforms individually and independently of the <a href="styling/transform.html#transform"><code>transform</code></a> property.</p>
<pre><code class="language-css">/* Single values */
/* values of more than 1 or 100% make the element grow */
scale: 2;
/* values of less than 1 or 100% make the element shrink */
scale: 50%;

/* Two values */
scale: 2 0.5;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-properties"><a class="header" href="#other-properties">Other Properties</a></h1>
<h2 id="cursor"><a class="header" href="#cursor">Cursor</a></h2>
<p>The <code>cursor</code> property sets the mouse cursor, if any, to show when the mouse pointer is over a view.</p>
<pre><code class="language-css">/* Keyword value */
cursor: auto;
cursor: pointer;
/* … */
cursor: zoom-out;
</code></pre>
<h2 id="pointer-events"><a class="header" href="#pointer-events">Pointer Events</a></h2>
<p>The <code>pointer-events</code> property sets under what circumstances (if any) a view can become the target of pointer events.</p>
<pre><code class="language-css">/* Keyword values */
pointer-events: auto;
pointer-events: none;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<p>The position and size of a view is determined by its layout properties. Vizia uses a custom layout system called <a href="https://github.com/vizia/morphorm">morphorm</a> which can achieve similar results to flexbox.</p>
<p>The following sections details the functioning of the layout system:</p>
<ul>
<li><a href="layout/./size.html">Size</a></li>
<li><a href="layout/./layout_type.html">Layout Type</a></li>
<li><a href="layout/./alignment.html">Alignment</a></li>
<li><a href="layout/./padding.html">Padding</a></li>
<li><a href="layout/./gap.html">Gap</a></li>
<li><a href="layout/./position_type.html">Position Type</a></li>
<li><a href="layout/./spacing.html">Spacing</a></li>
<li><a href="layout/./constraints.html">Constraints</a></li>
</ul>
<h2 id="units"><a class="header" href="#units">Units</a></h2>
<p>Many of the layout properties used in vizia use the <code>Units</code> type to specify their value. The <code>Units</code> type has four variants:</p>
<ul>
<li>Pixels</li>
<li>Percentage</li>
<li>Stretch</li>
<li>Auto</li>
</ul>
<p>Not all variants may have an effect on a particular property. For example, the padding properties do not use the stretch or auto variants.</p>
<h3 id="pixels"><a class="header" href="#pixels">Pixels</a></h3>
<p>The <strong>pixels</strong> variant allows space and size to be specified with a fixed number of logical pixels. The physical space or size is determined by the window scale factor:</p>
<pre><code>physical_pixels = logical_pixels * scale_factor
</code></pre>
<h3 id="percentage"><a class="header" href="#percentage">Percentage</a></h3>
<p>The <strong>percentage</strong> variant allows space and size to be specified as a fraction of the parent size:</p>
<pre><code>computed_value = percentage_value * parent_size / 100.0
</code></pre>
<p>The dimension is consistent, so specifying the <code>left</code> space as a percentage will use the parent <code>width</code> to calculate the desired space.</p>
<h3 id="stretch"><a class="header" href="#stretch">Stretch</a></h3>
<p>The <strong>stretch</strong> variant allows space and size within a stack to be specified as a ratio of the remaining free space of the parent after subtracting any fixed-size space and size.</p>
<p>This is best understood with an example. For two views in a horizontal stack, the first with a width of stretch factor 1.0 and the second with a width of stretch factor 2.0, the first will occupy 1/3 of the horizontal free space and the second will occupy 2/3 of the horizontal free space.</p>
<h3 id="auto"><a class="header" href="#auto">Auto</a></h3>
<p>The <strong>auto</strong> variant is typically the default value for a layout property and has no effect. The exception to this is with the size and size constraint properties, where an auto value represents the total size of the children of a view. So for example, setting the <code>width</code> to <code>auto</code> will cause the view to 'hug' its children in the horizontal direction.</p>
<h2 id="layout-properties"><a class="header" href="#layout-properties">Layout Properties</a></h2>
<p>This section provides a list of the currently supported style properties in vizia.</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Type</th><th>Initial Value</th><th>Inherited</th><th>Animatable</th></tr></thead><tbody>
<tr><td><code>layout-type</code></td><td><code>LayoutType</code></td><td><code>column</code></td><td>No</td><td>No</td></tr>
<tr><td><code>position-type</code></td><td><code>PositionType</code></td><td><code>relative</code></td><td>No</td><td>No</td></tr>
<tr><td><code>gap</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>horizontal-gap</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>vertical-gap</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>min-gap</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>min-horizontal-gap</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>min-vertical-gap</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>max-gap</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>max-horizontal-gap</code></td><td><code>Units</code></td><td><code>0px</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>max-vertical-gap</code></td><td><code>Units</code></td><td><code>solid</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>padding</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>padding-left</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>padding-right</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>padding-top</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>padding-bottom</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>size</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>width</code></td><td><code>Units</code></td><td><code>1s</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>height</code></td><td><code>Units</code></td><td><code>1s</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>min-size</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>min-width</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>min-height</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>max-size</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>max-width</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>max-height</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>space</code></td><td>shorthand</td><td></td><td></td><td></td></tr>
<tr><td><code>left</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>right</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>top</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>bottom</code></td><td><code>Units</code></td><td><code>auto</code></td><td>No</td><td>Yes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="size"><a class="header" href="#size">Size</a></h1>
<p>The <code>size</code> of a view is controlled by the <code>width</code> and <code>height</code> properties, and can be specified using pixels, a percentage, a stretch factor, or auto.</p>
<h2 id="fixed-size-pixels"><a class="header" href="#fixed-size-pixels">Fixed Size (Pixels)</a></h2>
<p>The width and height of a view can be specified with a number of logical pixels. In this case changes to the size of the parent view, or to the children of the view, will have no effect on its size.</p>
<p><img src="layout/../layout/images/fixed_width.svg" alt="fixed_width" /></p>
<h2 id="percentage-size"><a class="header" href="#percentage-size">Percentage Size</a></h2>
<p>The width and height of a view can also be specified as a percentage of the parent view size.</p>
<p><img src="layout/../layout/images/percentage_width.svg" alt="percentage_width" /></p>
<h2 id="stretch-size"><a class="header" href="#stretch-size">Stretch Size</a></h2>
<p>The width and height of a view can also be specified with a stretch factor, which will cause the view to fill a proportion of the free space.</p>
<p><img src="layout/../layout/images/stretch_width.svg" alt="stretch_width" /></p>
<p>For example, given the following code:</p>
<pre><code class="language-rust">HStack::new(cx, |cx|{
    Label::new(cx, "Hello")
        .background_color(Color::gray())
        .width(Stretch(1.0));

    Label::new(cx, "World")
        .width(Stretch(2.0));
});</code></pre>
<p>The first label occupies 1/3 of the horizontal space and the second occupies 2/3 of the free space.</p>
<p>The free space is the size of the parent in the main axis (width for row, height for column) minus any fixed space/size.</p>
<h2 id="auto-size-hug"><a class="header" href="#auto-size-hug">Auto Size (Hug)</a></h2>
<p>The width and height of a view can be specified as <code>auto</code>, which results in the view 'hugging' its children in the specified axis.</p>
<p><img src="layout/../layout/images/auto_width.svg" alt="auto_width" /></p>
<p>For example, given the following code:</p>
<pre><code class="language-rust">HStack::new(cx, |cx|{
    Label::new(cx, "Hello");
    Label::new(cx, "World");
})
.height(Auto);</code></pre>
<p>The height of the <code>HStack</code> is specified as <code>Auto</code>, which causes the computed height to become the maximum of its child heights.</p>
<p>If we had specified the hstack width to be <code>Auto</code>, then the computed width would be the sum of the widths of its children.</p>
<h2 id=""><a class="header" href="#"></a></h2>
<p>The <code>width</code> and <code>height</code> of a view can be specified using the respective layout modifiers which use the <code>Units</code> type:</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .background_color(Color::gray())
    .width(Pixels(200.0))
    .height(Pixels(30.0));</code></pre>
<p>The width and height can also be set simultaneously with the <code>size</code> layout modifier:</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .background_color(Color::gray())
    .size(Pixels(50.0));</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.hello_label {
    width: 20px;
    height: 1s;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-type-direction"><a class="header" href="#layout-type-direction">Layout Type (Direction)</a></h1>
<p>The <code>layout-type</code> determines the direction which a parent will stack its children. A parent element can arrange its children into a vertical stack (<code>layout-type: column</code>) or a horizontal stack (<code>layout-type: row</code>).</p>
<p><img src="layout/../layout/images/layout_type.svg" alt="layout_type" /></p>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<p>The <code>layout-type</code> of a view can be specified using the respective layout modifier:</p>
<pre><code class="language-rust">VStack::new(cx, |cx|{
    Label::new(cx, "Hello");
    Label::new(cx, "World");
})
.layout_type(LayoutType::Row);</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.container {
    layout-type: row;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alignment"><a class="header" href="#alignment">Alignment</a></h1>
<p>The <code>alignment</code> property determines how the children will be aligned within a view. There are 9 options:</p>
<ul>
<li><code>top-left</code></li>
<li><code>top-center</code></li>
<li><code>top-right</code></li>
<li><code>left</code></li>
<li><code>center</code></li>
<li><code>right</code></li>
<li><code>bottom-left</code></li>
<li><code>bottom-center</code></li>
<li><code>bottom-right</code></li>
</ul>
<p>Alignment also applies to text within a view, unless overridden by the <code>text-align</code> property.</p>
<p><img src="layout/../layout/images/alignment.svg" alt="alignment" /></p>
<h2 id="-2"><a class="header" href="#-2"></a></h2>
<p>The <code>alignment</code> of a view can be specified using the respective layout modifier:</p>
<pre><code class="language-rust">VStack::new(cx, |cx|{
    Label::new(cx, "Hello");
    Label::new(cx, "World");
})
.alignment(Alignment::Center);</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.container {
    alignment: center;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="padding"><a class="header" href="#padding">Padding</a></h1>
<p>The <code>padding</code> property, Shorthand for <code>padding-left</code>, <code>padding-top</code>, <code>padding-right</code>, and <code>padding-bottom</code>, determines the spacing between the parent bounds and the children of a view. It can be specified as pixels or a percentage.</p>
<p><img src="layout/../layout/images/padding.svg" alt="padding" /></p>
<h2 id="-3"><a class="header" href="#-3"></a></h2>
<p>The <code>padding-left</code>, <code>padding-top</code>, <code>padding-right</code>, and <code>padding-bottom</code> of a view can be specified using the respective layout modifiers:</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .background_color(Color::gray())
    .padding_left(Pixels(5.0))
    .padding_top(Pixels(10.0))
    .padding_right(Pixels(15.0))
    .padding_bottom(Pixels(20.0));</code></pre>
<p>The <code>padding</code> modifier can also be used to set all four sides simultaneously:</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .background_color(Color::gray())
    .padding(Pixels(20.0));</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.hello_label {
    padding_left: 5px;
    padding_top: 10px;
    padding_right: 15px;
    padding_bottom: 20px;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gap"><a class="header" href="#gap">Gap</a></h1>
<p>The <code>gap</code> property, shorthand for <code>horizontal-gap</code> and <code>vertical-gap</code>, determines the spacing between the children of a view. It can be specified as pixels, a percentage, or a stretch factor.</p>
<p><img src="layout/../layout/images/gap.svg" alt="gap" /></p>
<h2 id="stretch-gap"><a class="header" href="#stretch-gap">Stretch Gap</a></h2>
<p>Setting the gap to a stretch factor will result in evenly distributed space between children.</p>
<p><img src="layout/../layout/images/stretch_gap.svg" alt="stretch_gap" /></p>
<h2 id="negative-gap"><a class="header" href="#negative-gap">Negative Gap</a></h2>
<p>A negative pixels value for gap can be used and results in the children of the view overlapping.</p>
<p><img src="layout/../layout/images/negative_gap.svg" alt="negative_gap" /></p>
<h2 id="-4"><a class="header" href="#-4"></a></h2>
<p>The <code>gap</code> of a view can be specified using the respective layout modifier:</p>
<pre><code class="language-rust">VStack::new(cx, |cx|{
    Label::new(cx, "Hello");
    Label::new(cx, "World");
})
.gap(Pixels(20.0));</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.container {
    gap: 20px;
}
</code></pre>
<p>The <code>horizontal-gap</code> and <code>vertical-gap</code> can also be set independently:</p>
<pre><code class="language-rust">VStack::new(cx, |cx|{
    Label::new(cx, "Hello");
    Label::new(cx, "World");
})
.horizontal_gap(Pixels(20.0))
.vertical_gap(Pixels(10.0));</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.container {
    horizontal-gap: 20px;
    vertical-gap: 10px;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="position-type"><a class="header" href="#position-type">Position Type</a></h1>
<p>The position type property determines whether a view should be positioned in-line with its siblings in a stack (<code>position-type: relative</code>), which is the default, or out-of-line and independently of its siblings (<code>position-type: absolute</code>).</p>
<p><img src="layout/../layout/images/position_type.svg" alt="position-type" /></p>
<h2 id="-5"><a class="header" href="#-5"></a></h2>
<p>The <code>position-type</code> of a view can be specified using the respective layout modifier:</p>
<pre><code class="language-rust">VStack::new(cx, |cx|{
    Label::new(cx, "Hello");
    Label::new(cx, "World");
})
.position_type(PositionType::Absolute);</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.container {
    position-type: absolute;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spacing"><a class="header" href="#spacing">Spacing</a></h1>
<p>Spacing applies only to children with a position type of absolute, and is specified using the <code>left</code>, <code>right</code>, <code>top</code>, and <code>bottom</code> properties, or the <code>space</code> property as a shorthand. Each of these properties can have a value in pixels, a percentage, or a stretch factor.</p>
<p>A combination of pixels and stretch spacing can be used to align a view within its parent. For example, stretch factors can be used to center a view by applying equal stretch factors to all spacing properties.</p>
<p><img src="layout/../layout/images/spacing.svg" alt="spacing" /></p>
<h2 id="-6"><a class="header" href="#-6"></a></h2>
<p>The <code>left</code>, <code>top</code>, <code>right</code>, and <code>bottom</code> of a view can be specified using the respective layout modifiers:</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .background_color(Color::gray())
    .position_type(PositionType::Absolute)
    .left(Pixels(5.0))
    .top(Pixels(10.0))
    .right(Pixels(15.0))
    .bottom(Pixels(20.0));</code></pre>
<p>The <code>space</code> modifier can also be used to set all four sides simultaneously:</p>
<pre><code class="language-rust">Label::new(cx, "Hello World")
    .background_color(Color::gray())
    .position_type(PositionType::Absolute)
    .space(Pixels(20.0));</code></pre>
<p>Or in CSS:</p>
<pre><code class="language-css">.hello_label {
    left: 5px;
    top: 10px;
    right: 15px;
    bottom: 20px;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constraints"><a class="header" href="#constraints">Constraints</a></h1>
<p>Constraint properties can be used to specify a minimum or maximum value for size or gap.</p>
<h2 id="size-constraints"><a class="header" href="#size-constraints">Size Constraints</a></h2>
<p>Size constraints can have a value in pixels, a percentage, or auto.</p>
<p>The <code>min-size</code> property, which is shorthand for <code>min_width</code> and <code>min_height</code>, can be used to set a minimum constraint for the size of a view.</p>
<p><img src="layout/../layout/images/min_width.svg" alt="min_width" /></p>
<p>The <code>max-size</code> property, which is shorthand for <code>max_width</code> and <code>max_height</code>, can be used to set a maximum constraint for the size of a view.</p>
<p><img src="layout/../layout/images/max_width.svg" alt="max_width" /></p>
<h3 id="auto-min-widthheight"><a class="header" href="#auto-min-widthheight">Auto min-width/height</a></h3>
<p>An auto <code>min-width</code> or <code>min-height</code> can be used to specify that a view should not be any smaller than its contents, i.e. the sum or max of its children depending on layout type, in the horizontal or vertical directions respectively.</p>
<p>This is useful in combination with a stretch size, so the view can contract with its parent container but still maintain a minimum size of its content, for example the text of a view.</p>
<p><img src="layout/../layout/images/auto_min_width.svg" alt="auto_min_width" /></p>
<h3 id="auto-max-widthheight"><a class="header" href="#auto-max-widthheight">Auto max-width/height</a></h3>
<p>An auto <code>max-width</code> or <code>max-height</code> can be used to specify that a view should not be any larger than its contents, i.e. the sum or max of its children depending on layout type, in the horizontal or vertical directions respectively.</p>
<p>This is useful in combination with a stretch size, so the view can grow with its parent container but no larger than the size of its content.</p>
<p><img src="layout/../layout/images/auto_max_width.svg" alt="auto_max_width" /></p>
<h2 id="gap-constraints"><a class="header" href="#gap-constraints">Gap Constraints</a></h2>
<p>Gap constraints can have a value in pixels or a percentage.</p>
<p>The <code>min-gap</code> property, which is shorthand for <code>min_horizontal_gap</code> and <code>min_vertical_gap</code>, can be used to set a minimum constraint for the gap between the children of a view. This is particularly useful in combination with a stretch gap, so that the children are evenly distributed but cannot be closer than the minimum gap When the parent container shrinks.</p>
<p><img src="layout/../layout/images/min_gap.svg" alt="min_gap" /></p>
<p>Similarly, the <code>max-gap</code> property, which is shorthand for <code>max_horizontal_gap</code> and <code>max_vertical_gap</code>, can be used to set a maximum constraint for the gap between the children of a view.</p>
<p><img src="layout/../layout/images/max_gap.svg" alt="max_gap" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
